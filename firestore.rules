/**
 * @fileoverview Firestore Security Rules for the aaura app.
 *
 * Core Philosophy:
 * This ruleset employs a strict user-ownership model for personal data while allowing public read access to certain top-level collections.  All write operations require authentication and authorization checks.
 *
 * Data Structure:
 * - User-specific data is nested under `/users/{userId}`.
 * - Public content (media, deities, temples, stories, etc.) resides in top-level collections.
 * - Likes, followers, and memberships are modeled as subcollections for scalability.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Listing users is disallowed.
 * - Public collections (e.g., `/media`, `/deities`, `/temples`) are readable by everyone.
 * - Write access to public collections is restricted to authorized users, typically based on ownership (e.g., `media.userId` must match `request.auth.uid`).
 * - Relational integrity is enforced by validating key relationships on `create` and enforcing immutability on `update`.
 *
 * Denormalization for Authorization:
 *  To avoid costly `get()` calls, critical authorization data (like ownership) should be stored directly on the documents being secured.  For example, a `/media/{mediaId}` document should have a `userId` field representing the owner.
 *
 * Structural Segregation:
 * Private user data is kept separate from public data to simplify security rules and improve performance.  For example, user-specific playlists are under `/users/{userId}/playlists/{playlistId}`, while public playlists are under `/playlists/{playlistId}`.
 */

rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    // Match Statements

    /**
     * @description Manages user profile access.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' can create their profile.
     * @allow (get) User with UID 'user123' can read their own profile.
     * @allow (update) User with UID 'user123' can update their profile.
     * @deny (create) User with UID 'user456' cannot create a profile for 'user123'.
     * @deny (get) User with UID 'user456' cannot read 'user123's profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user followers.
     * @path /users/{userId}/followers/{followerId}
     * @allow (create) User 'follower456' can follow user 'user123'.
     * @allow (get) User 'user123' can read who is following them ('follower456').
     * @deny (create) User 'user123' cannot create a follower entry for 'follower456'.
     * @deny (update) No updates allowed.
     * @principle Enforces user-managed follow relationships.
     */
    match /users/{userId}/followers/{followerId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == followerId;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages users a user is following.
     * @path /users/{userId}/following/{followedId}
     * @allow (create) User 'user123' can follow user 'followed789'.
     * @allow (get) User 'user123' can read who they are following ('followed789').
     * @deny (create) User 'user123' cannot create a following entry for 'followed789'.
     * @deny (update) No updates allowed.
     * @principle Enforces user-managed follow relationships.
     */
    match /users/{userId}/following/{followedId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if false;
      allow delete: if isExistingOwner(userId);
    }


    /**
     * @description Manages user preferences.
     * @path /users/{userId}/preferences/default
     * @allow (create) User with UID 'user123' can create their preferences.
     * @allow (get) User with UID 'user123' can read their own preferences.
     * @allow (update) User with UID 'user123' can update their preferences.
     * @deny (create) User with UID 'user456' cannot create preferences for 'user123'.
     * @deny (get) User with UID 'user456' cannot read 'user123's preferences.
     * @principle Enforces document ownership for user preferences.
     */
    match /users/{userId}/preferences/default {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Manages user badges.
     * @path /users/{userId}/badges/{badgeId}
     * @allow (create) Server can award a badge to a user (implementation not defined here).
     * @allow (get) User with UID 'user123' can read their own badge.
     * @deny (create) User with UID 'user456' cannot create a badge for 'user123'.
     * @deny (update) No updates allowed.
     * @principle Enforces server-side badge awarding.
     */
    match /users/{userId}/badges/{badgeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if false; // Server-side implementation needed
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages user bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (create) User with UID 'user123' can bookmark a temple.
     * @allow (get) User with UID 'user123' can read their own bookmark.
     * @deny (create) User with UID 'user456' cannot create a bookmark for 'user123'.
     * @deny (update) No updates allowed.
     * @principle Enforces document ownership for bookmarks.
     */
    match /users/{userId}/bookmarks/{bookmarkId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if false;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user virtual offerings.
     * @path /users/{userId}/virtualOfferings/{offeringId}
     * @allow (create) User with UID 'user123' can make a virtual offering.
     * @allow (get) User with UID 'user123' can read their own virtual offerings.
     * @deny (create) User with UID 'user456' cannot create a virtual offering for 'user123'.
     * @deny (update) No updates allowed.
     * @principle Enforces document ownership for virtual offerings.
     */
    match /users/{userId}/virtualOfferings/{offeringId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if false;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user cart items.
     * @path /users/{userId}/cart/{productId}
     * @allow (create) User with UID 'user123' can add an item to their cart.
     * @allow (get) User with UID 'user123' can read their own cart.
     * @allow (update) User with UID 'user123' can update items in their own cart.
     * @deny (create) User with UID 'user456' cannot add an item to 'user123's cart.
     * @deny (get) User with UID 'user456' cannot read 'user123's cart.
     * @principle Enforces document ownership for shopping carts.
     */
    match /users/{userId}/cart/{productId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create) User with UID 'user123' can place an order.
     * @allow (get) User with UID 'user123' can read their own order.
     * @deny (create) User with UID 'user456' cannot create an order for 'user123'.
     * @deny (update) No updates allowed.
     * @principle Enforces document ownership for orders.
     */
     match /users/{userId}/orders/{orderId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.userId == userId;
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Manages user playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create) User with UID 'user123' can create a playlist.
     * @allow (get) User with UID 'user123' can read their own playlists.
     * @deny (create) User with UID 'user456' cannot create a playlist for 'user123'.
     * @deny (update) No updates allowed.
     * @principle Enforces document ownership for playlists.
     */
    match /users/{userId}/playlists/{playlistId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Manages user challenge progress.
      * @path /users/{userId}/challenges/{challengeId}
      * @allow (create) User with UID 'user123' can start a challenge.
      * @allow (get) User with UID 'user123' can read their own challenge progress.
      * @deny (create) User with UID 'user456' cannot create a challenge progress for 'user123'.
      * @deny (update) No updates allowed.
      * @principle Enforces document ownership for user challenges.
      */
    match /users/{userId}/challenges/{challengeId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.resource.data.challengeId == challengeId;
        allow update: if isExistingOwner(userId);
        allow delete: if false;
    }

    /**
     * @description Manages media content.
     * @path /media/{mediaId}
     * @allow (get) Anyone can read media content.
     * @allow (list) Anyone can list media content.
     * @allow (create) User with UID 'user123' can create media with matching userId.
     * @allow (update) User with UID 'user123' can update their own media.
     * @deny (create) User with UID 'user456' cannot create media for 'user123' without proper userId.
     * @principle Public read access with owner-only writes.
     */
    match /media/{mediaId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Manages comments on media items.
     * @path /media/{mediaId}/comments/{commentId}
     * @allow (create) User with UID 'user123' can comment on media.
     * @allow (get) Anyone can read a comment on media.
     * @allow (list) Anyone can list comments on media.
     * @principle Allows anyone to read/list comments, but enforces ownership on create.
     */
    match /media/{mediaId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages likes on media items.
     * @path /media/{mediaId}/likes/{userId}
     * @allow (create) User with UID 'user123' can like media.
     * @allow (get) Anyone can read the likes on media.
     * @allow (list) Anyone can list the likes on media.
     * @deny (update) No updates allowed.
     * @principle Public read access, user-specific likes.
     */
    match /media/{mediaId}/likes/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if false;
        allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Manages channel information.
      * @path /channels/{channelId}
      * @allow (get) Anyone can read channel information.
      * @allow (list) Anyone can list channel information.
      * @allow (create) User with UID 'user123' can create channel if channelId == userId.
      * @allow (update) User with UID 'user123' can update their own channel.
      * @deny (create) User with UID 'user456' cannot create channel for 'user123'.
      * @principle Public read access with owner-only writes, enforces channel/user ID match on creation.
      */
    match /channels/{channelId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.auth.uid == channelId && request.resource.data.userId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.userId);
        allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Manages public playlists.
     * @path /playlists/{playlistId}
     * @allow (get) Anyone can read public playlists.
     * @allow (list) Anyone can list public playlists.
     * @allow (create) User with UID 'user123' can create public playlist.
     * @allow (update) User with UID 'user123' can update their own playlist.
     * @deny (create) User with UID 'user456' cannot create public playlist for 'user123'.
     * @principle Public read access with owner-only writes.
     */
    match /playlists/{playlistId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.creatorId);
        allow delete: if isExistingOwner(resource.data.creatorId);
    }

    /**
     * @description Manages user horoscopes.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (get) User with UID 'user123' can read their own horoscopes.
     * @deny (create) User with UID 'user456' cannot create a horoscope for 'user123'.
     * @deny (update) No updates allowed.
     * @principle Enforces document ownership for horoscopes.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if false; // Horoscopes are generated server-side
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages deity information.
     * @path /deities/{deityId}
     * @allow (get) Anyone can read deity information.
     * @allow (list) Anyone can list deity information.
     * @deny (create) No direct client-side creation allowed.
     * @deny (update) No direct client-side updates allowed.
     * @principle Public read access, admin-only writes.
     */
    match /deities/{deityId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;  // Admin-only via backend
      allow update: if false;  // Admin-only via backend
      allow delete: if false;  // Admin-only via backend
    }

    /**
     * @description Manages shop information.
     * @path /shops/{shopId}
     * @allow (get) Anyone can read shop information.
     * @allow (list) Anyone can list shop information.
     * @allow (create) User with UID 'user123' can create shop with matching ownerId.
     * @allow (update) User with UID 'user123' can update their own shop.
     * @deny (create) User with UID 'user456' cannot create shop for 'user123'.
     * @principle Public read access with owner-only writes.
     */
    match /shops/{shopId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.ownerId);
        allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Manages product information.
     * @path /products/{productId}
     * @allow (get) Anyone can read product information.
     * @allow (list) Anyone can list product information.
     * @deny (create) No direct client-side creation allowed.
     * @deny (update) No direct client-side updates allowed.
     * @principle Public read access, admin-only writes.
     */
    match /products/{productId} {
        allow get: if true;
        allow list: if true;
        allow create: if false;  // Admin-only via backend
        allow update: if false;  // Admin-only via backend
        allow delete: if false;  // Admin-only via backend
    }

    /**
     * @description Manages temple information.
     * @path /temples/{templeId}
     * @allow (get) Anyone can read temple information.
     * @allow (list) Anyone can list temple information.
     * @deny (create) No direct client-side creation allowed.
     * @deny (update) No direct client-side updates allowed.
     * @principle Public read access, admin-only writes.
     */
    match /temples/{templeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;  // Admin-only via backend
      allow update: if false;  // Admin-only via backend
      allow delete: if false;  // Admin-only via backend
    }

    /**
     * @description Manages temple reviews.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (create) User with UID 'user123' can create a review.
     * @allow (get) Anyone can read a review.
     * @allow (list) Anyone can list reviews.
     * @deny (create) User with UID 'user456' cannot create a review for 'user123'.
     * @principle Allows anyone to read/list reviews, but enforces ownership on create.
     */
    match /temples/{templeId}/reviews/{reviewId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.userId);
        allow delete: if isExistingOwner(resource.data.userId);
    }

     /**
      * @description Manages forum posts within a temple.
      * @path /temples/{templeId}/posts/{postId}
      * @allow (create) User with UID 'user123' can create a post.
      * @allow (get) Anyone can read a post.
      * @allow (list) Anyone can list posts.
      * @deny (create) User with UID 'user456' cannot create a post for 'user123'.
      * @principle Allows anyone to read/list posts, but enforces ownership on create.
      */
    match /temples/{templeId}/posts/{postId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.authorId);
        allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages mythological stories.
     * @path /stories/{storyId}
     * @allow (get) Anyone can read stories.
     * @allow (list) Anyone can list stories.
     * @deny (create) No direct client-side creation allowed.
     * @deny (update) No direct client-side updates allowed.
     * @principle Public read access, admin-only writes.
     */
    match /stories/{storyId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // Admin-only via backend
      allow update: if false; // Admin-only via backend
      allow delete: if false; // Admin-only via backend
    }

    /**
     * @description Manages epic heroes.
     * @path /epicHeroes/{heroId}
     * @allow (get) Anyone can read epic heroes.
     * @allow (list) Anyone can list epic heroes.
     * @deny (create) No direct client-side creation allowed.
     * @deny (update) No direct client-side updates allowed.
     * @principle Public read access, admin-only writes.
     */
    match /epicHeroes/{heroId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // Admin-only via backend
      allow update: if false; // Admin-only via backend
      allow delete: if false; // Admin-only via backend
    }

    /**
     * @description Manages rituals.
     * @path /rituals/{ritualId}
     * @allow (get) Anyone can read rituals.
     * @allow (list) Anyone can list rituals.
     * @deny (create) No direct client-side creation allowed.
     * @deny (update) No direct client-side updates allowed.
     * @principle Public read access, admin-only writes.
     */
    match /rituals/{ritualId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // Admin-only via backend
      allow update: if false; // Admin-only via backend
      allow delete: if false; // Admin-only via backend
    }

    /**
     * @description Manages daily panchang data.
     * @path /panchang/{date}
     * @allow (get) Anyone can read panchang data.
     * @allow (list) Anyone can list panchang data.
     * @deny (create) No direct client-side creation allowed.
     * @deny (update) No direct client-side updates allowed.
     * @principle Public read access, admin-only writes.
     */
    match /panchang/{date} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // Admin-only via backend
      allow update: if false; // Admin-only via backend
      allow delete: if false; // Admin-only via backend
    }

    /**
     * @description Manages festival data.
     * @path /festivals/{festivalId}
     * @allow (get) Anyone can read festival data.
     * @allow (list) Anyone can list festival data.
     * @deny (create) No direct client-side creation allowed.
     * @deny (update) No direct client-side updates allowed.
     * @principle Public read access, admin-only writes.
     */
    match /festivals/{festivalId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // Admin-only via backend
      allow update: if false; // Admin-only via backend
      allow delete: if false; // Admin-only via backend
    }

     /**
      * @description Manages community groups.
      * @path /groups/{groupId}
      * @allow (get) Anyone can read group information.
      * @allow (list) Anyone can list group information.
      * @deny (create) No direct client-side creation allowed.
      * @deny (update) No direct client-side updates allowed.
      * @principle Public read access, admin-only writes.
      */
    match /groups/{groupId} {
        allow get: if true;
        allow list: if true;
        allow create: if false;  // Admin-only via backend
        allow update: if false;  // Admin-only via backend
        allow delete: if false;  // Admin-only via backend
    }

    /**
     * @description Manages group memberships.
     * @path /groups/{groupId}/members/{userId}
     * @allow (create) User with UID 'user123' can join the group.
     * @allow (get) Anyone can see who is a member of the group.
     * @allow (list) Anyone can list the members of the group.
     * @principle Allows anyone to read/list members.
     */
    match /groups/{groupId}/members/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if false;
        allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Manages forum posts within a group.
      * @path /posts/{postId}
      * @allow (create) User with UID 'user123' can create a post.
      * @allow (get) Anyone can read a post.
      * @allow (list) Anyone can list posts.
      * @deny (create) User with UID 'user456' cannot create a post for 'user123'.
      * @principle Allows anyone to read/list posts, but enforces ownership on create.
      */
    match /posts/{postId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.authorId);
        allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages comments on forum posts.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (create) User with UID 'user123' can comment on a post.
     * @allow (get) Anyone can read a comment.
     * @allow (list) Anyone can list comments.
     * @deny (create) User with UID 'user456' cannot create a comment for 'user123'.
     * @principle Allows anyone to read/list comments, but enforces ownership on create.
     */
    match /posts/{postId}/comments/{commentId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.authorId);
        allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages likes on forum posts.
     * @path /posts/{postId}/likes/{userId}
     * @allow (create) User with UID 'user123' can like a post.
     * @allow (get) Anyone can read the likes.
     * @allow (list) Anyone can list the likes.
     * @deny (update) No updates allowed.
     * @principle Public read access, user-specific likes.
     */
    match /posts/{postId}/likes/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if false;
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages community challenges.
     * @path /challenges/{challengeId}
     * @allow (get) Anyone can read challenge information.
     * @allow (list) Anyone can list challenge information.
     * @deny (create) No direct client-side creation allowed.
     * @deny (update) No direct client-side updates allowed.
     * @principle Public read access, admin-only writes.
     */
    match /challenges/{challengeId} {
        allow get: if true;
        allow list: if true;
        allow create: if false;  // Admin-only via backend
        allow update: if false;  // Admin-only via backend
        allow delete: if false;  // Admin-only via backend
    }

    /**
     * @description Manages manifestation techniques.
     * @path /manifestations/{manifestationId}
     * @allow (get) Anyone can read a manifestation.
     * @allow (list) Anyone can list manifestations.
     * @allow (create) User with UID 'user123' can create manifestation technique with matching userId.
     * @allow (update) User with UID 'user123' can update their own manifestation.
     * @deny (create) User with UID 'user456' cannot create a manifestation for 'user123'.
     * @principle Public read access with owner-only writes.
     */
    match /manifestations/{manifestationId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.userId);
        allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Manages comments on manifestation posts.
     * @path /manifestations/{manifestationId}/comments/{commentId}
     * @allow (create) User with UID 'user123' can comment on a manifestation.
     * @allow (get) Anyone can read a comment.
     * @allow (list) Anyone can list comments.
     * @deny (create) User with UID 'user456' cannot create a comment for 'user123'.
     * @principle Allows anyone to read/list comments, but enforces ownership on create.
     */
    match /manifestations/{manifestationId}/comments/{commentId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.authorId);
        allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages likes on manifestation posts.
     * @path /manifestations/{manifestationId}/likes/{userId}
     * @allow (create) User with UID 'user123' can like a manifestation.
     * @allow (get) Anyone can read the likes.
     * @allow (list) Anyone can list the likes.
     * @deny (update) No updates allowed.
     * @principle Public read access, user-specific likes.
     */
    match /manifestations/{manifestationId}/likes/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if false;
        allow delete: if isExistingOwner(userId);
    }
  }
}