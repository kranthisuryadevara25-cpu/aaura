/**
 * @fileoverview Firestore Security Rules for the aaura app.
 *
 * Core Philosophy:
 * This ruleset employs a strict user-ownership model for personal data and a public-read, owner-write model for publicly accessible content.
 *
 * Data Structure:
 * - User-specific data (profiles, preferences, bookmarks, cart, orders, playlists, horoscopes, challenges, contest progress) is nested under `/users/{userId}`.
 * - Public content (media, channels, playlists, deities, shops, products, temples, stories, epic heroes, rituals, panchang, festivals, groups, posts, challenges, contests, manifestations) is stored in top-level collections.
 *
 * Key Security Decisions:
 * - Users can only access and modify their own data.
 * - Public content is readable by all, but write access is restricted to authorized users (typically the content owner).
 * - Listing of user subcollections is restricted to the owner.
 * - The `preferences` document is treated as a singleton.
 * - Relational integrity is enforced on `create` and `update` operations to maintain data consistency.
 * - For shared content and social relationships, data is denormalized into the documents to avoid complex queries in security rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing document.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' can create their profile.
     *   - auth: { uid: 'user123' }
     *   - request.resource.data: { id: 'user123', email: 'test@example.com' }
     * @allow (get, update, delete) User with UID 'user123' can read and modify their profile.
     *   - auth: { uid: 'user123' }
     * @deny (create) User with UID 'user456' cannot create a profile for user 'user123'.
     *   - auth: { uid: 'user456' }
     *   - request.resource.data: { id: 'user123', email: 'test@example.com' }
     * @deny (update, delete) User with UID 'user456' cannot modify the profile of user 'user123'.
     *   - auth: { uid: 'user456' }
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

       /**
        * @description Rules for user contest progress tracking.
        * @path /users/{userId}/contestProgress/{contestId}
        * @allow (create, get, update, delete, list) User with UID 'user123' can manage their contest progress.
        *   - auth: { uid: 'user123' }
        * @deny (create, get, update, delete) User with UID 'user456' cannot manage the contest progress of user 'user123'.
        *   - auth: { uid: 'user456' }
        * @principle Restricts access to a user's own data tree.
        */
    match /users/{userId}/contestProgress/{contestId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Rules for user followers.
      * @path /users/{userId}/followers/{followerId}
      * @allow (create) User 'follower456' can follow user 'user123'.
      *   - auth: { uid: 'follower456' }
      * @allow (get, list) User 'user123' can list their followers.
      *   - auth: { uid: 'user123' }
      * @deny (create, update, delete) User 'user456' cannot manage followers of user 'user123'.
      *   - auth: { uid: 'user456' }
      * @principle Enforces document ownership and follower-followee relationship.
      */
    match /users/{userId}/followers/{followerId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if request.auth.uid == followerId;
        allow update: if false;
        allow delete: if request.auth.uid == followerId;
    }

    /**
     * @description Rules for users they are following.
     * @path /users/{userId}/following/{followedId}
     * @allow (create) User 'user123' can follow user 'followed789'.
     *   - auth: { uid: 'user123' }
     * @allow (get, list) User 'user123' can list the users they are following.
     *   - auth: { uid: 'user123' }
     * @deny (create, update, delete) User 'user456' cannot manage the follow list of user 'user123'.
     *   - auth: { uid: 'user456' }
     * @principle Enforces document ownership and follower-followee relationship.
     */
    match /users/{userId}/following/{followedId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId) && request.auth.uid == userId;
        allow update: if false;
        allow delete: if isOwner(userId) && request.auth.uid == userId;
    }

    /**
     * @description Rules for user preferences.
     * @path /users/{userId}/preferences/default
     * @allow (get, update) User with UID 'user123' can manage their preferences.
     *   - auth: { uid: 'user123' }
     * @deny (create, delete) No one can create or delete the preferences document.
     * @deny (get, update) User with UID 'user456' cannot manage preferences of user 'user123'.
     *   - auth: { uid: 'user456' }
     * @principle Restricts access to a user's own preferences.
     */
    match /users/{userId}/preferences/default {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if false;
      allow update: if isExistingOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Rules for user badges.
     * @path /users/{userId}/badges/{badgeId}
     * @allow (get, list) User with UID 'user123' can view their badges.
     *   - auth: { uid: 'user123' }
     * @allow (create) System can award badges, but we're not implementing that here.
     * @deny (create, update, delete) User with UID 'user456' cannot manage the badges of user 'user123'.
     *   - auth: { uid: 'user456' }
     * @principle Restricts access to a user's own badges.
     */
    match /users/{userId}/badges/{badgeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if false; // TODO: Implement admin role for awarding badges
      allow update: if false;
      allow delete: if false;
    }

     /**
      * @description Rules for user bookmarks.
      * @path /users/{userId}/bookmarks/{bookmarkId}
      * @allow (get, list, create, update, delete) User with UID 'user123' can manage their bookmarks.
      *   - auth: { uid: 'user123' }
      * @deny (get, list, create, update, delete) User with UID 'user456' cannot manage the bookmarks of user 'user123'.
      *   - auth: { uid: 'user456' }
      * @principle Restricts access to a user's own bookmarks.
      */
    match /users/{userId}/bookmarks/{bookmarkId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user virtual offerings.
     * @path /users/{userId}/virtualOfferings/{offeringId}
     * @allow (get, list, create, update, delete) User with UID 'user123' can manage their virtual offerings.
     *   - auth: { uid: 'user123' }
     * @deny (get, list, create, update, delete) User with UID 'user456' cannot manage the virtual offerings of user 'user123'.
     *   - auth: { uid: 'user456' }
     * @principle Restricts access to a user's own virtual offerings.
     */
    match /users/{userId}/virtualOfferings/{offeringId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user shopping cart.
     * @path /users/{userId}/cart/{productId}
     * @allow (get, list, create, update, delete) User with UID 'user123' can manage their cart items.
     *   - auth: { uid: 'user123' }
     * @deny (get, list, create, update, delete) User with UID 'user456' cannot manage the cart of user 'user123'.
     *   - auth: { uid: 'user456' }
     * @principle Restricts access to a user's own shopping cart.
     */
    match /users/{userId}/cart/{productId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Rules for user orders.
      * @path /users/{userId}/orders/{orderId}
      * @allow (get, list, create) User with UID 'user123' can view and create their orders.
      *   - auth: { uid: 'user123' }
      * @deny (update, delete) Users cannot update or delete orders.
      * @deny (get, list, create) User with UID 'user456' cannot manage the orders of user 'user123'.
      *   - auth: { uid: 'user456' }
      * @principle Restricts access to a user's own orders.
      */
    match /users/{userId}/orders/{orderId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if false;
        allow delete: if false;
    }

    /**
     * @description Rules for user playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (get, list, create, update, delete) User with UID 'user123' can manage their playlists.
     *   - auth: { uid: 'user123' }
     * @deny (get, list, create, update, delete) User with UID 'user456' cannot manage the playlists of user 'user123'.
     *   - auth: { uid: 'user456' }
     * @principle Restricts access to a user's own playlists.
     */
    match /users/{userId}/playlists/{playlistId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user challenge progress.
     * @path /users/{userId}/challenges/{challengeId}
     * @allow (get, list, create, update, delete) User with UID 'user123' can manage their challenge progress.
     *   - auth: { uid: 'user123' }
     * @deny (get, list, create, update, delete) User with UID 'user456' cannot manage the challenge progress of user 'user123'.
     *   - auth: { uid: 'user456' }
     * @principle Restricts access to a user's own challenge progress.
     */
    match /users/{userId}/challenges/{challengeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for media content.
     * @path /media/{mediaId}
     * @allow (get, list) Public read access.
     * @allow (create) Owner of the media can create it.
     *   - request.resource.data.userId == request.auth.uid
     * @allow (update, delete) Owner of the media can modify it.
     *   - resource.data.userId == request.auth.uid
     * @principle Public read, owner-only writes.
     */
    match /media/{mediaId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

    /**
     * @description Rules for media comments.
     * @path /media/{mediaId}/comments/{commentId}
     * @allow (get, list, create) Any authenticated user can read and create comments.
     * @allow (update, delete) Only the author of the comment can modify it.
     * @principle Authenticated users can create and read comments, owner-only updates and deletes.
     */
    match /media/{mediaId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for media likes.
     * @path /media/{mediaId}/likes/{userId}
     * @allow (get, list) Public read access.
     * @allow (create, delete) Authenticated user can like/unlike media.
     * @principle Public read, authenticated users can like.
     */
    match /media/{mediaId}/likes/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if false;
      allow delete: if isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Rules for channels.
     * @path /channels/{channelId}
     * @allow (get, list) Public read access.
     * @allow (create) Owner of the channel can create it.
     *   - request.resource.data.userId == request.auth.uid
     * @allow (update, delete) Owner of the channel can modify it.
     *   - resource.data.userId == request.auth.uid
     * @principle Public read, owner-only writes.
     */
    match /channels/{channelId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

    /**
     * @description Rules for playlists.
     * @path /playlists/{playlistId}
     * @allow (get, list) Public read access.
     * @allow (create) Owner of the playlist can create it.
     *   - request.resource.data.creatorId == request.auth.uid
     * @allow (update, delete) Owner of the playlist can modify it.
     *   - resource.data.creatorId == request.auth.uid
     * @principle Public read, owner-only writes.
     */
    match /playlists/{playlistId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.creatorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.creatorId);
    }

    /**
     * @description Rules for user horoscopes.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (get, list, create, update, delete) User with UID 'user123' can manage their horoscopes.
     *   - auth: { uid: 'user123' }
     * @deny (get, list, create, update, delete) User with UID 'user456' cannot manage the horoscopes of user 'user123'.
     *   - auth: { uid: 'user456' }
     * @principle Restricts access to a user's own horoscopes.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for deities.
     * @path /deities/{deityId}
     * @allow (get, list) Public read access.
     * @allow create, update, delete: if false; // TODO: Implement admin role
     * @principle Public read, restricted writes.
     */
    match /deities/{deityId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add admin role validation
      allow update: if false; // TODO: Add admin role validation
      allow delete: if false; // TODO: Add admin role validation
    }

     /**
      * @description Rules for shops.
      * @path /shops/{shopId}
      * @allow (get, list) Public read access.
      * @allow (create) Owner of the shop can create it.
      *   - request.resource.data.ownerId == request.auth.uid
      * @allow (update, delete) Owner of the shop can modify it.
      *   - resource.data.ownerId == request.auth.uid
      * @principle Public read, owner-only writes.
      */
    match /shops/{shopId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.ownerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Rules for products.
     * @path /products/{productId}
     * @allow (get, list) Public read access.
     * @allow create, update, delete: if false; // TODO: Need to add validation for the shop owner
     * @principle Public read, restricted writes.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add shop owner validation
      allow update: if false; // TODO: Add shop owner validation
      allow delete: if false;  // TODO: Add shop owner validation
    }

    /**
     * @description Rules for temples.
     * @path /temples/{templeId}
     * @allow (get, list) Public read access.
     * @allow create, update, delete: if false; // TODO: Implement admin role for temple management
     * @principle Public read, restricted writes.
     */
    match /temples/{templeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;  // TODO: Add admin role validation
      allow update: if false; // TODO: Add admin role validation
      allow delete: if false; // TODO: Add admin role validation
    }

    /**
     * @description Rules for temple reviews.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (get, list, create) Any authenticated user can read and create reviews.
     * @allow (update, delete) Only the author of the review can modify it.
     * @principle Authenticated users can create and read reviews, owner-only updates and deletes.
     */
    match /temples/{templeId}/reviews/{reviewId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Rules for temple posts.
     * @path /temples/{templeId}/posts/{postId}
     * @allow (get, list, create) Any authenticated user can read and create posts.
     * @allow (update, delete) Only the author of the post can modify it.
     * @principle Authenticated users can create and read posts, owner-only updates and deletes.
     */
    match /temples/{templeId}/posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for mythological stories.
     * @path /stories/{storyId}
     * @allow (get, list) Public read access.
     * @allow create, update, delete: if false; // TODO: Implement admin role for story management
     * @principle Public read, restricted writes.
     */
    match /stories/{storyId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add admin role validation
      allow update: if false; // TODO: Add admin role validation
      allow delete: if false; // TODO: Add admin role validation
    }

    /**
     * @description Rules for epic heroes.
     * @path /epicHeroes/{heroId}
     * @allow (get, list) Public read access.
     * @allow create, update, delete: if false; // TODO: Implement admin role for epic hero management
     * @principle Public read, restricted writes.
     */
    match /epicHeroes/{heroId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;  // TODO: Add admin role validation
      allow update: if false; // TODO: Add admin role validation
      allow delete: if false; // TODO: Add admin role validation
    }

    /**
     * @description Rules for rituals.
     * @path /rituals/{ritualId}
     * @allow (get, list) Public read access.
     * @allow create, update, delete: if false; // TODO: Implement admin role for ritual management
     * @principle Public read, restricted writes.
     */
    match /rituals/{ritualId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add admin role validation
      allow update: if false; // TODO: Add admin role validation
      allow delete: if false; // TODO: Add admin role validation
    }

    /**
     * @description Rules for daily panchang data.
     * @path /panchang/{date}
     * @allow (get, list) Public read access.
     * @allow create, update, delete: if false; // TODO: Implement admin role for panchang management
     * @principle Public read, restricted writes.
     */
    match /panchang/{date} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add admin role validation
      allow update: if false; // TODO: Add admin role validation
      allow delete: if false; // TODO: Add admin role validation
    }

    /**
     * @description Rules for cultural festivals.
     * @path /festivals/{festivalId}
     * @allow (get, list) Public read access.
     * @allow create, update, delete: if false; // TODO: Implement admin role for festival management
     * @principle Public read, restricted writes.
     */
    match /festivals/{festivalId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;  // TODO: Add admin role validation
      allow update: if false; // TODO: Add admin role validation
      allow delete: if false; // TODO: Add admin role validation
    }

    /**
     * @description Rules for community groups.
     * @path /groups/{groupId}
     * @allow (get, list) Public read access.
     * @allow create: if isSignedIn(); // Any authenticated user can create a group
     * @allow update, delete: if false; // TODO: Add validation for group admin
     * @principle Public read, authenticated users can create, owner-only update and delete.
     */
    match /groups/{groupId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false; // TODO: Add group admin validation
      allow delete: if false; // TODO: Add group admin validation
    }

    /**
     * @description Rules for group members.
     * @path /groups/{groupId}/members/{userId}
     * @allow (get, list) Authenticated users can see group members.
     * @allow create, delete: if isSignedIn() && request.auth.uid == userId; // Users can join/leave groups
     * @allow update: if false;
     * @principle Authenticated users can see group members, and join/leave groups.
     */
    match /groups/{groupId}/members/{userId} {
      allow get: if isSignedIn();
      allow list: if isSignedIn();
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if false;
      allow delete: if isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Rules for posts within a group.
     * @path /posts/{postId}
     * @allow (get, list) Public read access.
     * @allow create: if isSignedIn(); // Any authenticated user can create a post
     * @allow update, delete: if isExistingOwner(resource.data.authorId); // Only the author can update/delete
     * @principle Public read, authenticated users can create, owner-only update and delete.
     */
    match /posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for comments on posts within a group.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (get, list) Public read access.
     * @allow create: if isSignedIn(); // Any authenticated user can create a comment
     * @allow update, delete: if isExistingOwner(resource.data.authorId); // Only the author can update/delete
     * @principle Public read, authenticated users can create, owner-only update and delete.
     */
    match /posts/{postId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for likes on forum posts.
     * @path /posts/{postId}/likes/{userId}
     * @allow (get, list) Public read access.
     * @allow create, delete: if isSignedIn() && request.auth.uid == userId; // User can like/unlike a post
     * @principle Public read, authenticated users can like.
     */
    match /posts/{postId}/likes/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if false;
      allow delete: if isSignedIn() && request.auth.uid == userId;
    }

      /**
       * @description Rules for community challenges.
       * @path /challenges/{challengeId}
       * @allow (get, list) Public read access.
       * @allow create, update, delete: if false; // TODO: Implement admin role for challenge management
       * @principle Public read, restricted writes.
       */
    match /challenges/{challengeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;  // TODO: Add admin role validation
      allow update: if false; // TODO: Add admin role validation
      allow delete: if false; // TODO: Add admin role validation
    }

    /**
     * @description Rules for global chanting contests.
     * @path /contests/{contestId}
     * @allow (get, list) Public read access.
     * @allow create, update, delete: if false; // TODO: Implement admin role for contest management
     * @principle Public read, restricted writes.
     */
    match /contests/{contestId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;  // TODO: Add admin role validation
      allow update: if false; // TODO: Add admin role validation
      allow delete: if false; // TODO: Add admin role validation
    }

      /**
       * @description Rules for manifestation posts.
       * @path /manifestations/{manifestationId}
       * @allow (get, list) Public read access.
       * @allow (create) Authenticated user can create a post.
       *   - request.resource.data.userId == request.auth.uid
       * @allow (update, delete) Only the author of the post can modify it.
       * @principle Public read, authenticated users can create, owner-only updates and deletes.
       */
    match /manifestations/{manifestationId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Rules for comments on manifestation posts.
     * @path /manifestations/{manifestationId}/comments/{commentId}
     * @allow (get, list) Public read access.
     * @allow create: if isSignedIn(); // Any authenticated user can create a comment
     * @allow update, delete: if isExistingOwner(resource.data.authorId); // Only the author can update/delete
     * @principle Public read, authenticated users can create, owner-only update and delete.
     */
    match /manifestations/{manifestationId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for likes on manifestation posts.
     * @path /manifestations/{manifestationId}/likes/{userId}
     * @allow (get, list) Public read access.
     * @allow create, delete: if isSignedIn() && request.auth.uid == userId; // User can like/unlike a post
     * @principle Public read, authenticated users can like.
     */
    match /manifestations/{manifestationId}/likes/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if false;
      allow delete: if isSignedIn() && request.auth.uid == userId;
    }
  }
}