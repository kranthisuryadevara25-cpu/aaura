/**
 * @fileoverview Firestore Security Rules for the aaura app.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for private user data and a public-read, owner-write model for top-level content collections. All write operations must be authenticated.
 *
 * Data Structure:
 * - User-specific data is nested under /users/{userId}, including profile information, preferences, bookmarks, cart, and orders.
 * - Public content like media, channels, playlists, deities, temples, stories, rituals, panchang, festivals, groups, and manifestations are stored in top-level collections.
 * - Social connections (followers/following) are managed via user subcollections.
 * - Likes and comments are modeled as subcollections on their respective content documents for scalability.
 *
 * Key Security Decisions:
 * - Users can only read and write their own data under /users/{userId}.
 * - Top-level content collections are publicly readable but writable only by authenticated users (with ownership enforced where applicable).
 * - Listing of user subcollections (e.g., bookmarks, cart items) is allowed only for the owner.
 * - Updating relational fields (e.g., userId) is disallowed after creation.
 * - Authorization relies on the `request.auth` object for identity verification.
 *
 * Denormalization for Authorization:
 * - The `media` collection contains a `userId` field to identify the media's creator, enabling owner-based write rules.
 * - The `playlists` collection contains a `creatorId` field for the same purpose.
 * - The `shops` collection contains an `ownerId` field for owner-based write rules.
 * - The `posts` collection contains an `authorId` field to identify post creators.
 * - The `manifestations` collection contains a `userId` field to identify the creator.
 *
 * Structural Segregation:
 * - User-specific private data (e.g., bookmarks) and public content (e.g., temples) are stored in separate collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to manage their own profile data.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' creates their profile.
     * @allow (update) User with ID 'user123' updates their profile.
     * @allow (get) User with ID 'user123' reads their profile.
     * @deny (create) User with ID 'user456' tries to create a profile for 'user123'.
     * @deny (update) User with ID 'user456' tries to update the profile of 'user123'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Allows a user to create, read, update, and delete their own follower entries.
     * @path /users/{userId}/followers/{followerId}
     * @allow (create) User 'follower123' follows user 'user123'.
     * @allow (get) User 'user123' retrieves information about 'follower123' following them.
     * @allow (list) User 'user123' lists their followers.
     * @deny (create) User 'anotherUser' tries to create a follower entry for 'user123'.
     * @principle Enforces ownership: only the user being followed can manage their followers, and only the follower can create their follow entry.
     */
    match /users/{userId}/followers/{followerId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == followerId;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows a user to create, read, update, and delete their own following entries.
     * @path /users/{userId}/following/{followedId}
     * @allow (create) User 'user123' follows user 'followed456'.
     * @allow (get) User 'user123' retrieves information about who they are following.
     * @allow (list) User 'user123' lists who they are following.
     * @deny (create) User 'anotherUser' tries to create a following entry for 'user123'.
     * @principle Enforces ownership: only the user doing the following can manage their following entries.
     */
    match /users/{userId}/following/{followedId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.auth.uid == userId;
      allow update: if false;
      allow delete: if isSignedIn() && isOwner(userId) && request.auth.uid == userId;
    }

    /**
     * @description Allows users to manage their preferences. Uses a singleton document named "default".
     * @path /users/{userId}/preferences/default
     * @allow (get) User 'user123' retrieves their preferences.
     * @allow (create) User 'user123' creates their preferences.
     * @allow (update) User 'user123' updates their preferences.
     * @deny (get) User 'user456' attempts to retrieve 'user123' preferences.
     * @principle Enforces document ownership for user preferences.
     */
    match /users/{userId}/preferences/default {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Allows users to manage their awarded badges.
     * @path /users/{userId}/badges/{badgeId}
     * @allow (get) User 'user123' retrieves their badges.
     * @allow (list) User 'user123' lists their badges.
     * @deny (get) User 'user456' attempts to retrieve 'user123' badges.
     * @deny (create) User 'user123' attempts to create a badge directly (badges should be awarded by backend functions).
     * @principle Enforces document ownership for awarded badges.
     */
    match /users/{userId}/badges/{badgeId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows users to manage their saved temple bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (get) User 'user123' retrieves their bookmarks.
     * @allow (list) User 'user123' lists their bookmarks.
     * @allow (create) User 'user123' creates a bookmark.
     * @allow (delete) User 'user123' deletes a bookmark.
     * @deny (get) User 'user456' attempts to retrieve 'user123' bookmarks.
     * @principle Enforces document ownership for user bookmarks.
     */
    match /users/{userId}/bookmarks/{bookmarkId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if false;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

     /**
     * @description Allows users to manage their virtual offering logs.
     * @path /users/{userId}/virtualOfferings/{offeringId}
     * @allow (get) User 'user123' retrieves their virtual offerings.
     * @allow (list) User 'user123' lists their virtual offerings.
     * @allow (create) User 'user123' creates a virtual offering.
     * @deny (get) User 'user456' attempts to retrieve 'user123' virtual offerings.
     * @principle Enforces document ownership for virtual offerings.
     */
    match /users/{userId}/virtualOfferings/{offeringId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows users to manage items in their shopping cart.
     * @path /users/{userId}/cart/{productId}
     * @allow (get) User 'user123' retrieves an item from their cart.
     * @allow (list) User 'user123' lists items in their cart.
     * @allow (create) User 'user123' adds an item to their cart.
     * @allow (update) User 'user123' updates an item in their cart (e.g., quantity).
     * @allow (delete) User 'user123' removes an item from their cart.
     * @deny (get) User 'user456' attempts to retrieve 'user123' cart items.
     * @principle Enforces document ownership for shopping cart items.
     */
    match /users/{userId}/cart/{productId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Allows users to view and manage their past orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow (get) User 'user123' retrieves their order details.
     * @allow (list) User 'user123' lists their past orders.
     * @deny (get) User 'user456' attempts to retrieve 'user123' order details.
     * @deny (create) Users cannot directly create order documents (created by backend).
     * @deny (update) Users cannot update orders after creation.
     * @deny (delete) Users cannot delete orders.
     * @principle Enforces document ownership for user orders, read-only access for clients.
     */
    match /users/{userId}/orders/{orderId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows users to manage references to their created playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (get) User 'user123' retrieves a reference to their playlist.
     * @allow (list) User 'user123' lists references to their playlists.
     * @allow (create) User 'user123' creates a reference to their playlist.
     * @allow (delete) User 'user123' deletes a reference to their playlist.
     * @deny (get) User 'user456' attempts to retrieve 'user123' playlist references.
     * @principle Enforces document ownership for playlist references.
     */
    match /users/{userId}/playlists/{playlistId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if false;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Allows users to manage their progress in community challenges.
     * @path /users/{userId}/challenges/{challengeId}
     * @allow (get) User 'user123' retrieves their challenge progress.
     * @allow (list) User 'user123' lists their challenge progress.
     * @allow (create) User 'user123' starts a challenge.
     * @allow (update) User 'user123' updates their challenge progress.
     * @deny (get) User 'user456' attempts to retrieve 'user123' challenge progress.
     * @principle Enforces document ownership for user challenge progress.
     */
    match /users/{userId}/challenges/{challengeId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Allows public read access to media, but enforces owner-only write access.
     * @path /media/{mediaId}
     * @allow (get) Any user can retrieve media details.
     * @allow (list) Any user can list media items.
     * @allow (create) User 'user123' creates media with 'userId' field set to their UID.
     * @allow (update) User 'user123' updates media where the 'userId' field matches their UID.
     * @allow (delete) User 'user123' deletes media where the 'userId' field matches their UID.
     * @deny (create) User 'user456' tries to create media with 'userId' set to 'user123'.
     * @deny (update) User 'user456' tries to update media owned by 'user123'.
     * @principle Allows public read access while enforcing document ownership for writes.
     */
    match /media/{mediaId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

    /**
     * @description Allows comments to be created and read by anyone, but only the author can edit or delete them.
     * @path /media/{mediaId}/comments/{commentId}
     * @allow (get) Any user can retrieve a comment.
     * @allow (list) Any user can list comments for a media item.
     * @allow (create) User 'user123' creates a comment with 'authorId' set to their UID.
     * @allow (update) User 'user123' updates a comment where 'authorId' matches their UID.
     * @allow (delete) User 'user123' deletes a comment where 'authorId' matches their UID.
     * @deny (create) User 'user456' tries to create a comment with 'authorId' set to 'user123'.
     * @deny (update) User 'user456' tries to update a comment authored by 'user123'.
     * @principle Allows public read access while enforcing document ownership for writes.
     */
    match /media/{mediaId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

     /**
     * @description Allows any user to like a media.
     * @path /media/{mediaId}/likes/{userId}
     * @allow (create) Any authenticated user can like a media.
     * @allow (get) Any user can retrieve a like.
     * @deny (update) No one can update a like.
     * @principle Public like operation.
     */
    match /media/{mediaId}/likes/{userId} {
      allow get: if true;
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to channels, but enforces owner-only write access.
     * @path /channels/{channelId}
     * @allow (get) Any user can retrieve channel details.
     * @allow (list) Any user can list channels.
     * @allow (create) User 'user123' creates a channel with 'userId' field set to their UID.
     * @allow (update) User 'user123' updates channel where the 'userId' field matches their UID.
     * @allow (delete) User 'user123' deletes a channel where the 'userId' field matches their UID.
     * @deny (create) User 'user456' tries to create a channel with 'userId' set to 'user123'.
     * @deny (update) User 'user456' tries to update a channel owned by 'user123'.
     * @principle Allows public read access while enforcing document ownership for writes.
     */
    match /channels/{channelId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

    /**
     * @description Allows public read access to playlists, but enforces owner-only write access.
     * @path /playlists/{playlistId}
     * @allow (get) Any user can retrieve playlist details.
     * @allow (list) Any user can list playlists.
     * @allow (create) User 'user123' creates a playlist with 'creatorId' field set to their UID.
     * @allow (update) User 'user123' updates playlist where the 'creatorId' field matches their UID.
     * @allow (delete) User 'user123' deletes a playlist where the 'creatorId' field matches their UID.
     * @deny (create) User 'user456' tries to create a playlist with 'creatorId' set to 'user123'.
     * @deny (update) User 'user456' tries to update a playlist owned by 'user123'.
     * @principle Allows public read access while enforcing document ownership for writes.
     */
    match /playlists/{playlistId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.creatorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.creatorId);
    }

    /**
     * @description Allows users to read their own horoscopes. Horoscopes are read-only to the client.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (get) User 'user123' retrieves their horoscope.
     * @allow (list) User 'user123' lists their horoscopes.
     * @deny (get) User 'user456' attempts to retrieve 'user123' horoscope.
     * @deny (create) Users cannot create horoscope documents.
     * @principle Enforces document ownership for horoscope reads, prevents client writes.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to deity information.
     * @path /deities/{deityId}
     * @allow (get) Any user can retrieve deity details.
     * @allow (list) Any user can list deities.
     * @deny (create) No one can create deity documents via the client.
     * @principle Public read access, no client writes.
     */
    match /deities/{deityId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to shops, but enforces owner-only write access.
     * @path /shops/{shopId}
     * @allow (get) Any user can retrieve shop details.
     * @allow (list) Any user can list shops.
     * @allow (create) User 'user123' creates shop with 'ownerId' field set to their UID.
     * @allow (update) User 'user123' updates shop where the 'ownerId' field matches their UID.
     * @allow (delete) User 'user123' deletes shop where the 'ownerId' field matches their UID.
     * @deny (create) User 'user456' tries to create a shop with 'ownerId' set to 'user123'.
     * @deny (update) User 'user456' tries to update a shop owned by 'user123'.
     * @principle Allows public read access while enforcing document ownership for writes.
     */
    match /shops/{shopId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.ownerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Allows public read access to products.
     * @path /products/{productId}
     * @allow (get) Any user can retrieve product details.
     * @allow (list) Any user can list products.
     * @deny (create) No one can create products via the client.
     * @principle Public read access, no client writes.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to temple information.
     * @path /temples/{templeId}
     * @allow (get) Any user can retrieve temple details.
     * @allow (list) Any user can list temples.
     * @deny (create) No one can create temples via the client.
     * @principle Public read access, no client writes.
     */
    match /temples/{templeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows any authenticated user to create a review for a temple. Users can only manage their own reviews.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (get) Any user can retrieve a review.
     * @allow (list) Any user can list reviews for a temple.
     * @allow (create) User 'user123' creates review with their UID.
     * @allow (update) User 'user123' updates their own review.
     * @allow (delete) User 'user123' deletes their own review.
     * @deny (create) User 'user456' tries to create review for 'user123'.
     * @deny (update) User 'user456' tries to update review owned by 'user123'.
     * @principle Public read, owner-only write for reviews.
     */
    match /temples/{templeId}/reviews/{reviewId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

     /**
     * @description Allows users to create posts for a temple. Users can only manage their own posts.
     * @path /temples/{templeId}/posts/{postId}
     * @allow (get) Any user can retrieve a post.
     * @allow (list) Any user can list posts for a temple.
     * @allow (create) User 'user123' creates post with their UID.
     * @allow (update) User 'user123' updates their own post.
     * @allow (delete) User 'user123' deletes their own post.
     * @deny (create) User 'user456' tries to create post for 'user123'.
     * @deny (update) User 'user456' tries to update post owned by 'user123'.
     * @principle Public read, owner-only write for posts.
     */
    match /temples/{templeId}/posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows public read access to stories.
     * @path /stories/{storyId}
     * @allow (get) Any user can retrieve story details.
     * @allow (list) Any user can list stories.
     * @deny (create) No one can create stories via the client.
     * @principle Public read access, no client writes.
     */
    match /stories/{storyId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to epic hero information.
     * @path /epicHeroes/{heroId}
     * @allow (get) Any user can retrieve epic hero details.
     * @allow (list) Any user can list epic heroes.
     * @deny (create) No one can create epic heroes via the client.
     * @principle Public read access, no client writes.
     */
    match /epicHeroes/{heroId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to ritual information.
     * @path /rituals/{ritualId}
     * @allow (get) Any user can retrieve ritual details.
     * @allow (list) Any user can list rituals.
     * @deny (create) No one can create rituals via the client.
     * @principle Public read access, no client writes.
     */
    match /rituals/{ritualId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to panchang data.
     * @path /panchang/{date}
     * @allow (get) Any user can retrieve panchang details for a date.
     * @allow (list) Any user can list panchang data.
     * @deny (create) No one can create panchang data via the client.
     * @principle Public read access, no client writes.
     */
    match /panchang/{date} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to festival information.
     * @path /festivals/{festivalId}
     * @allow (get) Any user can retrieve festival details.
     * @allow (list) Any user can list festivals.
     * @deny (create) No one can create festivals via the client.
     * @principle Public read access, no client writes.
     */
    match /festivals/{festivalId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

   /**
     * @description Allows public read access to community groups.
     * @path /groups/{groupId}
     * @allow (get) Any user can retrieve group details.
     * @allow (list) Any user can list groups.
     * @deny (create) No one can create groups via the client.
     * @principle Public read access, no client writes.
     */
    match /groups/{groupId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows users to join or leave community groups.
     * @path /groups/{groupId}/members/{userId}
     * @allow (get) Any user can retrieve membership details.
     * @allow (list) Any user can list members of the group.
     * @allow (create) Any authenticated user can join the group.
     * @allow (delete) Any authenticated user can leave the group.
     * @deny (update) No one can update the group's members.
     * @principle Public join and leave operations for authenticated users.
     */
    match /groups/{groupId}/members/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if false;
      allow delete: if isSignedIn() && request.auth.uid == userId;
    }

     /**
     * @description Allows any authenticated user to create a post. Users can only manage their own posts.
     * @path /posts/{postId}
     * @allow (get) Any user can retrieve a post.
     * @allow (list) Any user can list posts for a group.
     * @allow (create) User 'user123' creates post with their UID.
     * @allow (update) User 'user123' updates their own post.
     * @allow (delete) User 'user123' deletes their own post.
     * @deny (create) User 'user456' tries to create post for 'user123'.
     * @deny (update) User 'user456' tries to update post owned by 'user123'.
     * @principle Public read, owner-only write for posts.
     */
    match /posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows comments to be created and read by anyone, but only the author can edit or delete them.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (get) Any user can retrieve a comment.
     * @allow (list) Any user can list comments for a post.
     * @allow (create) User 'user123' creates a comment with 'authorId' set to their UID.
     * @allow (update) User 'user123' updates a comment where 'authorId' matches their UID.
     * @allow (delete) User 'user123' deletes a comment where 'authorId' matches their UID.
     * @deny (create) User 'user456' tries to create a comment with 'authorId' set to 'user123'.
     * @deny (update) User 'user456' tries to update a comment authored by 'user123'.
     * @principle Allows public read access while enforcing document ownership for writes.
     */
    match /posts/{postId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows any user to like a post.
     * @path /posts/{postId}/likes/{userId}
     * @allow (create) Any authenticated user can like a post.
     * @allow (get) Any user can retrieve a like.
     * @deny (update) No one can update a like.
     * @principle Public like operation.
     */
    match /posts/{postId}/likes/{userId} {
      allow get: if true;
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to community challenges.
     * @path /challenges/{challengeId}
     * @allow (get) Any user can retrieve challenge details.
     * @allow (list) Any user can list challenges.
     * @deny (create) No one can create challenges via the client.
     * @principle Public read access, no client writes.
     */
    match /challenges/{challengeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows any authenticated user to create a manifestation. Users can only manage their own manifestations.
     * @path /manifestations/{manifestationId}
     * @allow (get) Any user can retrieve a manifestation.
     * @allow (list) Any user can list manifestations.
     * @allow (create) User 'user123' creates a manifestation with 'userId' field set to their UID.
     * @allow (update) User 'user123' updates their own manifestation.
     * @allow (delete) User 'user123' deletes their own manifestation.
     * @deny (create) User 'user456' tries to create manifestation for 'user123'.
     * @deny (update) User 'user456' tries to update manifestation owned by 'user123'.
     * @principle Public read, owner-only write for manifestations.
     */
    match /manifestations/{manifestationId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

   /**
     * @description Allows comments to be created and read by anyone, but only the author can edit or delete them.
     * @path /manifestations/{manifestationId}/comments/{commentId}
     * @allow (get) Any user can retrieve a comment.
     * @allow (list) Any user can list comments for a manifestation.
     * @allow (create) User 'user123' creates a comment with 'authorId' set to their UID.
     * @allow (update) User 'user123' updates a comment where 'authorId' matches their UID.
     * @allow (delete) User 'user123' deletes a comment where 'authorId' matches their UID.
     * @deny (create) User 'user456' tries to create a comment with 'authorId' set to 'user123'.
     * @deny (update) User 'user456' tries to update a comment authored by 'user123'.
     * @principle Allows public read access while enforcing document ownership for writes.
     */
    match /manifestations/{manifestationId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

     /**
     * @description Allows any user to like a manifestation.
     * @path /manifestations/{manifestationId}/likes/{userId}
     * @allow (create) Any authenticated user can like a manifestation.
     * @allow (get) Any user can retrieve a like.
     * @deny (update) No one can update a like.
     * @principle Public like operation.
     */
    match /manifestations/{manifestationId}/likes/{userId} {
      allow get: if true;
      allow list: if false;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if false;
      allow delete: if false;
    }


    // --- Helper functions ---

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the requesting user is the owner of the document, using the provided userId.
     * @param {string} userId The user ID to compare with the authenticated user's ID.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the requesting user is the owner of an existing document, using the provided userId.
     * @param {string} userId The user ID to compare with the authenticated user's ID.
     * @return {boolean} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
  }
}