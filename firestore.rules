/**
 * @fileoverview Firestore Security Rules for the aaura app.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data,
 * and a public-read, owner-write model for top-level content collections.
 *
 * Data Structure:
 * - User-specific data is nested under /users/{userId}.
 * - Top-level collections like /media, /channels, /playlists, /deities,
 *   /shops, /products, /temples, /stories, /characters, /rituals, /panchang, /festivals, and /posts
 *   store public or shared content.
 * - Subcollections are used for relational data (e.g., /temples/{templeId}/reviews/{reviewId}).
 *
 * Key Security Decisions:
 * - Users can only access their own data under /users/{userId}.
 * - Public content is readable by everyone, but only writable by authorized users (typically the content creator).
 * - User listing is disallowed for privacy.
 * - The ruleset prioritizes security and assumes that all write operations must be explicitly permitted.
 * - The rules do not validate data types or schema, except for fields used in authorization.
 *
 * Denormalization for Authorization:
 *  - Ownership is enforced by requiring the 'userId' field within documents to match the path.
 *  - This enables simple, efficient `isOwner()` checks without requiring additional `get()` calls.
 *
 * Structural Segregation:
 *  - Private user data is stored under the /users/{userId} path.
 *  - Public data, like media content and temple information, is stored in top-level collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated (user is signed in).
     * @returns {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     * @param {string} userId The user ID to compare against.
     * @returns {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

     /**
      * @description Checks if the authenticated user is the owner and the document exists.
      * @param {string} userId The user ID to compare against.
      * @returns {boolean} True if the user is the owner and the document exists, false otherwise.
      */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Rule set for user profiles.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' can create their profile.
     *   request.auth.uid = 'user123'
     *   request.resource.data.id = 'user123'
     * @allow (get, update, delete) User with UID 'user123' can read, update, and delete their profile.
     *   request.auth.uid = 'user123'
     *   resource.data.id = 'user123'
     * @deny (create) User with UID 'user456' cannot create a profile for 'user123'.
     *   request.auth.uid = 'user456'
     *   request.resource.data.id = 'user123'
     * @deny (get, update, delete) User with UID 'user456' cannot read, update, or delete the profile of 'user123'.
     *   request.auth.uid = 'user456'
     *   resource.data.id = 'user123'
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is disallowed for privacy.
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rule set for followers subcollection.
     * @path /users/{userId}/followers/{followerId}
     * @allow (create, get, list) User can read their list of followers.
     *   request.auth.uid = 'user123'
     *   resource.data.userId = 'user123'
     * @allow (delete) User 'follower456' can stop following 'user123'.
     *   request.auth.uid = 'follower456'
     * @deny (create) User 'user456' cannot add 'follower789' to 'user123' followers list.
     *   request.auth.uid = 'user456'
     * @principle Followers can only be added by the system, and users can remove themselves as followers.
     */
    match /users/{userId}/followers/{followerId} {
      allow get, list: if isOwner(userId);
      allow create: if false; // Follower relationships managed by backend, not client
      allow update: if false;
      allow delete: if isSignedIn() && request.auth.uid == followerId;
    }

    /**
     * @description Rule set for following subcollection.
     * @path /users/{userId}/following/{followedId}
     * @allow (create, get, list) User can read who they are following.
     *   request.auth.uid = 'user123'
     *   resource.data.userId = 'user123'
     * @allow (delete) User 'user123' can unfollow 'followed456'.
     *   request.auth.uid = 'user123'
     * @deny (create) User 'user456' cannot make 'user123' follow 'followed789'.
     *   request.auth.uid = 'user456'
     * @principle Users can manage their own follow list.
     */
    match /users/{userId}/following/{followedId} {
      allow get, list: if isOwner(userId);
      allow create: if false; // Following relationships managed by backend, not client
      allow update: if false;
      allow delete: if isOwner(userId);
    }

    /**
     * @description Rule set for user preferences.
     * @path /users/{userId}/preferences/default
     * @allow (get, update) User with UID 'user123' can read and update their preferences.
     *   request.auth.uid = 'user123'
     * @deny (get, update) User with UID 'user456' cannot read or update the preferences of 'user123'.
     *   request.auth.uid = 'user456'
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/preferences/default {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if false;
      allow update: if isExistingOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Rule set for user badges.
     * @path /users/{userId}/badges/{badgeId}
     * @allow (get, list) User can view their own badges
     *   request.auth.uid = 'user123'
     * @deny (create, update, delete) Badges are awarded by the system, so users cannot create, update, or delete them.
     *   request.auth.uid = 'user123'
     * @principle Badges are managed by the system, not individual users.
     */
    match /users/{userId}/badges/{badgeId} {
      allow get, list: if isOwner(userId);
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

     /**
      * @description Rule set for user bookmarks.
      * @path /users/{userId}/bookmarks/{bookmarkId}
      * @allow (create, get, list, delete) User can manage their own bookmarks
      *   request.auth.uid = 'user123'
      * @deny (create, get, list, delete) Another user cannot manage 'user123's bookmarks
      *   request.auth.uid = 'user456'
      * @principle Bookmarks are private to each user.
      */
    match /users/{userId}/bookmarks/{bookmarkId} {
      allow get, list, create, delete: if isOwner(userId);
      allow update: if false;
    }

    /**
     * @description Rule set for virtual offerings.
     * @path /users/{userId}/virtualOfferings/{offeringId}
     * @allow (create, get, list) User can manage their own virtual offerings
     *   request.auth.uid = 'user123'
     * @deny (create, get, list) Another user cannot manage 'user123's virtual offerings
     *   request.auth.uid = 'user456'
     * @principle Virtual offerings are private to each user.
     */
    match /users/{userId}/virtualOfferings/{offeringId} {
      allow get, list, create: if isOwner(userId);
      allow update: if false;
      allow delete: if false;
    }

     /**
      * @description Rule set for items in a user's cart.
      * @path /users/{userId}/cart/{productId}
      * @allow (create, get, list, update, delete) User can manage their own cart.
      *   request.auth.uid = 'user123'
      * @deny (create, get, list, update, delete) Another user cannot manage 'user123's cart.
      *   request.auth.uid = 'user456'
      */
    match /users/{userId}/cart/{productId} {
      allow get, list, create, update, delete: if isOwner(userId);
    }

    /**
     * @description Rule set for a user's orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create, get, list) User can view their own orders.
     *   request.auth.uid = 'user123'
     * @deny (create, get, list) Another user cannot view 'user123's orders.
     *   request.auth.uid = 'user456'
     * @deny (update, delete) User orders cannot be updated or deleted by the client.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list, create: if isOwner(userId);
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rule set for playlists created by a user.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (get, list) User can read the playlists they have created.
     *   request.auth.uid = 'user123'
     * @deny (create, update, delete) Playlists are managed from the top-level /playlists collection
     *   request.auth.uid = 'user123'
     * @principle Users can only read their playlist references; management is handled elsewhere.
     */
     match /users/{userId}/playlists/{playlistId} {
      allow get, list: if isOwner(userId);
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rule set for media content.
     * @path /media/{mediaId}
     * @allow (get, list) Anyone can read media content.
     * @allow (create) User can create media if the userId matches their auth.
     *   request.auth.uid = 'user123'
     *   request.resource.data.userId = 'user123'
     * @allow (update, delete) Only the owner can update/delete media content.
     *   request.auth.uid = 'user123'
     *   resource.data.userId = 'user123'
     * @principle Public read, owner-only writes.
     */
    match /media/{mediaId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Rule set for comments on media items.
     * @path /media/{mediaId}/comments/{commentId}
     * @allow (get, list) Anyone can read comments on media items.
     * @allow (create) Any signed-in user can create a comment.
     * @allow (update, delete) Only the comment author can update or delete their comment.
     * @principle Public read, owner-only writes for updates/deletes.
     */
    match /media/{mediaId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rule set for likes on media content.
     * @path /media/{mediaId}/likes/{userId}
     * @allow (get, list) Anyone can read the likes count for a media item.
     * @allow (create, delete) Any signed-in user can like/unlike a media item.
     * @deny (update) Liking/unliking shouldn't update the document content.
     */
    match /media/{mediaId}/likes/{userId} {
      allow get, list: if true;
      allow create, delete: if isSignedIn();
      allow update: if false;
    }

    /**
     * @description Rule set for channels.
     * @path /channels/{channelId}
     * @allow (get, list) Anyone can read channel information.
     * @allow (create) User can create channel if the userId matches their auth.
     *   request.auth.uid = 'user123'
     *   request.resource.data.userId = 'user123'
     * @allow (update, delete) Only the channel owner can update/delete.
     *   request.auth.uid = 'user123'
     *   resource.data.userId = 'user123'
     * @principle Public read, owner-only writes.
     */
    match /channels/{channelId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Rule set for playlists.
     * @path /playlists/{playlistId}
     * @allow (get, list) Anyone can read public playlists.
     * @allow (create) User can create playlist if the creatorId matches their auth.
     *   request.auth.uid = 'user123'
     *   request.resource.data.creatorId = 'user123'
     * @allow (update, delete) Only the playlist creator can update/delete.
     *   request.auth.uid = 'user123'
     *   resource.data.creatorId = 'user123'
     * @principle Public read, owner-only writes.
     */
    match /playlists/{playlistId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.creatorId);
      allow delete: if isExistingOwner(resource.data.creatorId);
    }

    /**
     * @description Rule set for horoscopes.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (get, list) User can only read their own horoscopes.
     * @deny (create, update, delete) Horoscopes are generated by the system, so users cannot create, update, or delete them.
     * @principle Horoscopes are managed by the system and are private to each user.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      allow get, list: if isOwner(userId);
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Rule set for deities.
     * @path /deities/{deityId}
     * @allow (get, list) Anyone can read deity information.
     * @deny (create, update, delete) Deity information is managed by administrators.
     * @principle Public read, admin-only writes.
     */
    match /deities/{deityId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin role check for writes.
    }

    /**
     * @description Rule set for shops.
     * @path /shops/{shopId}
     * @allow (get, list) Anyone can read shop information.
     * @allow (create) User can create shop if the ownerId matches their auth.
     *   request.auth.uid = 'user123'
     *   request.resource.data.ownerId = 'user123'
     * @allow (update, delete) Only the shop owner can update/delete.
     *   request.auth.uid = 'user123'
     *   resource.data.ownerId = 'user123'
     * @principle Public read, owner-only writes.
     */
    match /shops/{shopId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Rule set for products.
     * @path /products/{productId}
     * @allow (get, list) Anyone can read product information.
     * @deny (create, update, delete) Product information is managed by shop owners.
     * @principle Public read, shop owner-only writes (through backend).
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add shop owner check for writes.
    }

    /**
     * @description Rule set for temples.
     * @path /temples/{templeId}
     * @allow (get, list) Anyone can read temple information.
     * @deny (create, update, delete) Temple information is managed by administrators.
     * @principle Public read, admin-only writes.
     */
    match /temples/{templeId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin role check for writes.
    }

    /**
     * @description Rule set for temple reviews.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (get, list) Anyone can read reviews for a temple.
     * @allow (create) Any signed-in user can create a review.
     * @allow (update, delete) Only the review author can update or delete their review.
     * @principle Public read, owner-only writes for updates/deletes.
     */
    match /temples/{templeId}/reviews/{reviewId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

     /**
      * @description Rule set for stories.
      * @path /stories/{storyId}
      * @allow (get, list) Anyone can read story information.
      * @deny (create, update, delete) Story information is managed by administrators.
      * @principle Public read, admin-only writes.
      */
    match /stories/{storyId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin role check for writes.
    }

     /**
      * @description Rule set for characters.
      * @path /characters/{characterId}
      * @allow (get, list) Anyone can read character information.
      * @deny (create, update, delete) Character information is managed by administrators.
      * @principle Public read, admin-only writes.
      */
    match /characters/{characterId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin role check for writes.
    }

    /**
     * @description Rule set for rituals.
     * @path /rituals/{ritualId}
     * @allow (get, list) Anyone can read ritual information.
     * @deny (create, update, delete) Ritual information is managed by administrators.
     * @principle Public read, admin-only writes.
     */
    match /rituals/{ritualId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin role check for writes.
    }

    /**
     * @description Rule set for panchang data.
     * @path /panchang/{date}
     * @allow (get, list) Anyone can read panchang data.
     * @deny (create, update, delete) Panchang data is managed by administrators.
     * @principle Public read, admin-only writes.
     */
    match /panchang/{date} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin role check for writes.
    }

    /**
     * @description Rule set for festivals.
     * @path /festivals/{festivalId}
     * @allow (get, list) Anyone can read festival information.
     * @deny (create, update, delete) Festival information is managed by administrators.
     * @principle Public read, admin-only writes.
     */
    match /festivals/{festivalId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add admin role check for writes.
    }

     /**
      * @description Rule set for forum posts.
      * @path /posts/{postId}
      * @allow (get, list) Anyone can read forum posts.
      * @allow (create) Any signed-in user can create a post.
      *   request.auth.uid = 'user123'
      *   request.resource.data.authorId = 'user123'
      * @allow (update, delete) Only the post author can update or delete their post.
      *   request.auth.uid = 'user123'
      *   resource.data.authorId = 'user123'
      * @principle Public read, owner-only writes for updates/deletes.
      */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rule set for comments on forum posts.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (get, list) Anyone can read comments on forum posts.
     * @allow (create) Any signed-in user can create a comment.
     * @allow (update, delete) Only the comment author can update or delete their comment.
     * @principle Public read, owner-only writes for updates/deletes.
     */
    match /posts/{postId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rule set for likes on forum posts.
     * @path /posts/{postId}/likes/{userId}
     * @allow (get, list) Anyone can read the likes for a post.
     * @allow (create, delete) Any signed-in user can like/unlike a post.
     * @deny (update) Liking/unliking shouldn't update the document content.
     */
    match /posts/{postId}/likes/{userId} {
      allow get, list: if true;
      allow create, delete: if isSignedIn();
      allow update: if false;
    }
  }
}