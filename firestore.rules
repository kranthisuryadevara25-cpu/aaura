/**
 * @fileoverview Firestore Security Rules for the aaura app.
 *
 * Core Philosophy:
 * This ruleset employs a strict user-ownership model for personal data,
 * combined with public read access for certain top-level collections like media,
 * deities, temples, stories, epic heroes, rituals, festivals, challenges, contests, and manifestations.
 * Write access to these public collections is restricted to authenticated users who must be the owners.
 *
 * Data Structure:
 * - User-specific data (profile, preferences, bookmarks, virtual offerings, cart, playlists, contest progress, horoscopes)
 *   is nested under `/users/{userId}`.
 * - Public content (media, channels, playlists, deities, temples, stories, epic heroes, rituals, festivals, challenges, contests, and manifestations)
 *   resides in top-level collections.
 * - Likes are stored as subcollections under both media and post documents.
 * - Comments are stored as subcollections under media and post documents.
 * - Orders are stored in a top-level collection for easier admin access.
 * - Followers and Following are stored as user subcollections.
 *
 * Key Security Decisions:
 * - Users can only read, create, update, and delete their own data under their respective user IDs.
 * - Public content is readable by everyone but writable only by identified owners.
 * - Listing of user documents is disallowed for privacy.
 * - Shop and Product are owner-accessible for write operations.
 * - Orders are accessible for any operation.
 *
 * Denormalization for Authorization:
 * - Public collections like `Media` should include a `userId` field to denote ownership. This avoids costly `get()` calls
 *   to other collections to verify ownership.
 *
 * Structural Segregation:
 * - Private user-specific data and public content are stored in separate collections to ensure
 *   that listing operations on public content do not expose private data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by an authenticated user.
     * @path N/A
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's UID matches the provided userId.
     * @path N/A
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

     /**
     * @description Checks if the authenticated user's UID matches the userId of an existing document.
     * @path N/A
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Enforces access control for user profiles.
     * @path /users/{userId}
     * @allow (create) - User with UID 'user123' can create their profile if request.auth.uid == 'user123'.
     * @allow (get, update, delete) - User with UID 'user123' can get, update, or delete their profile.
     * @deny (create) - User with UID 'user456' cannot create a profile for 'user123'.
     * @deny (get, update, delete) - User with UID 'user456' cannot get, update, or delete 'user123's profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user contest progress.
     * @path /users/{userId}/contestProgress/{contestId}
     * @allow (create) - User with UID 'user123' can create their contest progress if request.auth.uid == 'user123'.
     * @allow (get, update, delete) - User with UID 'user123' can get, update, or delete their contest progress.
     * @deny (create) - User with UID 'user456' cannot create contest progress for 'user123'.
     * @deny (get, update, delete) - User with UID 'user456' cannot get, update, or delete 'user123's contest progress.
     * @principle Enforces document ownership for user contest progress.
     */
    match /users/{userId}/contestProgress/{contestId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user followers.
     * @path /users/{userId}/followers/{followerId}
     * @allow (create) - User with UID 'user123' can follow another user.
     * @allow (get, list) - User with UID 'user123' can get/list their followers.
     * @deny (create) - User with UID 'user456' cannot create a follow entry for 'user123'.
     * @deny (get, list) - User with UID 'user456' cannot get/list 'user123's followers.
     * @principle Enforces document ownership for user followers.
     */
    match /users/{userId}/followers/{followerId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Enforces access control for users being followed.
     * @path /users/{userId}/following/{followedId}
     * @allow (create) - User with UID 'user123' can follow another user.
     * @allow (get, list) - User with UID 'user123' can get/list the users they are following.
     * @deny (create) - User with UID 'user456' cannot create a following entry for 'user123'.
     * @deny (get, list) - User with UID 'user456' cannot get/list the users 'user123' is following.
     * @principle Enforces document ownership for users being followed.
     */
    match /users/{userId}/following/{followedId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isOwner(userId);
    }

    /**
     * @description Enforces access control for user preferences.
     * @path /users/{userId}/preferences/default
     * @allow (get, update) - User with UID 'user123' can get/update their preferences.
     * @allow (create) - User with UID 'user123' can create their preferences.
     * @deny (get, update) - User with UID 'user456' cannot get/update 'user123's preferences.
     * @principle Enforces document ownership for user preferences.
     */
    match /users/{userId}/preferences/default {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Enforces access control for user badges.
     * @path /users/{userId}/badges/{badgeId}
     * @allow (get, list) - User with UID 'user123' can get/list their badges.
     * @allow (create) - User with UID 'user123' can create their badges.
     * @deny (get, list) - User with UID 'user456' cannot get/list 'user123's badges.
     * @principle Enforces document ownership for user badges.
     */
    match /users/{userId}/badges/{badgeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (get, list) - User with UID 'user123' can get/list their bookmarks.
     * @allow (create) - User with UID 'user123' can create their bookmarks.
     * @deny (get, list) - User with UID 'user456' cannot get/list 'user123's bookmarks.
     * @principle Enforces document ownership for user bookmarks.
     */
    match /users/{userId}/bookmarks/{bookmarkId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user virtual offerings.
     * @path /users/{userId}/virtualOfferings/{offeringId}
     * @allow (get, list) - User with UID 'user123' can get/list their virtual offerings.
     * @allow (create) - User with UID 'user123' can create their virtual offerings.
     * @deny (get, list) - User with UID 'user456' cannot get/list 'user123's virtual offerings.
     * @principle Enforces document ownership for user virtual offerings.
     */
    match /users/{userId}/virtualOfferings/{offeringId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user shopping carts.
     * @path /users/{userId}/cart/{productId}
     * @allow (get, list) - User with UID 'user123' can get/list their cart items.
     * @allow (create) - User with UID 'user123' can create their cart items.
     * @deny (get, list) - User with UID 'user456' cannot get/list 'user123's cart items.
     * @principle Enforces document ownership for user shopping carts.
     */
    match /users/{userId}/cart/{productId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows read and write access to orders.
     * @path /orders/{orderId}
     * @allow (get, list, create, update, delete) - any authenticated user can perform all operations.
     * @principle Open access for prototyping.
     */
    match /orders/{orderId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Enforces access control for user playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (get, list) - User with UID 'user123' can get/list their playlists.
     * @allow (create) - User with UID 'user123' can create their playlists.
     * @deny (get, list) - User with UID 'user456' cannot get/list 'user123's playlists.
     * @principle Enforces document ownership for user playlists.
     */
    match /users/{userId}/playlists/{playlistId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces access control for user challenge progress.
     * @path /users/{userId}/challenges/{challengeId}
     * @allow (get, list) - User with UID 'user123' can get/list their challenge progress.
     * @allow (create) - User with UID 'user123' can create their challenge progress.
     * @deny (get, list) - User with UID 'user456' cannot get/list 'user123's challenge progress.
     * @principle Enforces document ownership for user challenge progress.
     */
    match /users/{userId}/challenges/{challengeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to media, but restricts write access to owners.
     * @path /media/{mediaId}
     * @allow (get, list) - Any user can read media.
     * @allow (create, update, delete) - Only the owner can write media.
     * @deny (create) - If request.resource.data.userId does not match request.auth.uid.
     * @deny (update, delete) - If the media doesn't exist or the user is not the owner.
     * @principle Public read, owner-only write for media.
     */
    match /media/{mediaId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
    }

    /**
     * @description Enforces access control for comments on media items.
     * @path /media/{mediaId}/comments/{commentId}
     * @allow (get, list) - Any user can read comments on media.
     * @allow (create) - Any signed-in user can create a comment.
     * @deny (update, delete) - Only the owner can update/delete comments.
     * @principle Public read for comments, owner-only write.
     */
    match /media/{mediaId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

     /**
     * @description Enforces access control for likes on media items.
     * @path /media/{mediaId}/likes/{userId}
     * @allow (get, list) - Any user can read likes on media.
     * @allow (create) - Any signed-in user can create a like.
     * @allow (delete) - Only the owner can delete the like
     * @deny (update) - No one can update a like.
     * @principle Public read for likes, owner-only write.
     */
    match /media/{mediaId}/likes/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Allows public read access to channels, but restricts write access to owners.
     * @path /channels/{channelId}
     * @allow (get, list) - Any user can read channels.
     * @allow (create, update, delete) - Only the owner can write channels.
     * @deny (create) - If request.resource.data.userId does not match request.auth.uid.
     * @deny (update, delete) - If the channel doesn't exist or the user is not the owner.
     * @principle Public read, owner-only write for channels.
     */
    match /channels/{channelId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
    }

    /**
     * @description Allows public read access to playlists, but restricts write access to owners.
     * @path /playlists/{playlistId}
     * @allow (get, list) - Any user can read playlists.
     * @allow (create, update, delete) - Only the owner can write playlists.
     * @deny (create) - If request.resource.data.creatorId does not match request.auth.uid.
     * @deny (update, delete) - If the playlist doesn't exist or the user is not the owner.
     * @principle Public read, owner-only write for playlists.
     */
    match /playlists/{playlistId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.creatorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.creatorId == request.auth.uid && resource != null;
    }

    /**
     * @description Enforces access control for user horoscopes.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (get, list) - User with UID 'user123' can get/list their horoscopes.
     * @allow (create) - User with UID 'user123' can create their horoscopes.
     * @deny (get, list) - User with UID 'user456' cannot get/list 'user123's horoscopes.
     * @principle Enforces document ownership for user horoscopes.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to deities.
     * @path /deities/{deityId}
     * @allow (get, list) - Any user can read deities.
     * @allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read access.
     */
    match /deities/{deityId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows read and write access to shops.
     * @path /shops/{shopId}
     * @allow (get, list) - Any user can read shops.
     * @allow (create, update, delete) - Only the owner can write shops.
     * @deny (create) - If request.resource.data.ownerId does not match request.auth.uid.
     * @deny (update, delete) - If the shop doesn't exist or the user is not the owner.
     * @principle Owner-only write access for shops.
     */
    match /shops/{shopId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.ownerId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.ownerId == request.auth.uid && resource != null;
    }

    /**
     * @description Allows read and write access to products.
     * @path /products/{productId}
     * @allow (get, list) - Any user can read products.
     * @allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Open read access for products.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn(); // TODO: Add shop ownership validation to Product collection
      allow update: if isSignedIn(); // TODO: Add shop ownership validation to Product collection
      allow delete: if isSignedIn(); // TODO: Add shop ownership validation to Product collection
    }

    /**
     * @description Allows public read access to temples.
     * @path /temples/{templeId}
     * @allow (get, list) - Any user can read temples.
     * @allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read access.
     */
    match /temples/{templeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces access control for reviews on temples.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (get, list) - Any user can read reviews on temples.
     * @allow (create) - Any signed-in user can create a review.
     * @deny (update, delete) - Only the owner can update/delete reviews.
     * @principle Public read for reviews, owner-only write.
     */
    match /temples/{templeId}/reviews/{reviewId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
    }

    /**
     * @description Enforces access control for posts on temples.
     * @path /temples/{templeId}/posts/{postId}
     * @allow (get, list) - Any user can read posts on temples.
     * @allow (create) - Any signed-in user can create a post.
     * @deny (update, delete) - Only the owner can update/delete posts.
     * @principle Public read for posts, owner-only write.
     */
    match /temples/{templeId}/posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

    /**
     * @description Allows public read access to stories.
     * @path /stories/{storyId}
     * @allow (get, list) - Any user can read stories.
     * @allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read access.
     */
    match /stories/{storyId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to epic heroes.
     * @path /epicHeroes/{heroId}
     * @allow (get, list) - Any user can read epic heroes.
     * @allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read access.
     */
    match /epicHeroes/{heroId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to rituals.
     * @path /rituals/{ritualId}
     * @allow (get, list) - Any user can read rituals.
     * @allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read access.
     */
    match /rituals/{ritualId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to panchang data.
     * @path /panchang/{date}
     * @allow (get, list) - Any user can read panchang data.
     * @allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read access.
     */
    match /panchang/{date} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to festivals.
     * @path /festivals/{festivalId}
     * @allow (get, list) - Any user can read festivals.
     * @allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read access.
     */
    match /festivals/{festivalId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

     /**
     * @description Allows public read access to groups.
     * @path /groups/{groupId}
     * @allow (get, list) - Any user can read groups.
     * @allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read access.
     */
    match /groups/{groupId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn(); // TODO: Add shop ownership validation to Group collection
      allow update: if isSignedIn(); // TODO: Add shop ownership validation to Group collection
      allow delete: if isSignedIn(); // TODO: Add shop ownership validation to Group collection
    }

    /**
     * @description Enforces access control for group members.
     * @path /groups/{groupId}/members/{userId}
     * @allow (get, list) - Any user can read members of a group.
     * @allow (create) - Any signed-in user can create a membership.
     * @deny (update, delete) - No one can update/delete memberships.
     * @principle Public read for memberships, open create for joining.
     */
    match /groups/{groupId}/members/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Allows public read access to posts.
     * @path /posts/{postId}
     * @allow (get, list) - Any user can read posts.
     * @allow (create) - Any signed-in user can create posts.
     * @deny (update, delete) - Only the owner can update/delete posts.
     * @principle Public read for posts, owner-only write.
     */
    match /posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

    /**
     * @description Enforces access control for comments on posts.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (get, list) - Any user can read comments on posts.
     * @allow (create) - Any signed-in user can create a comment.
     * @deny (update, delete) - Only the owner can update/delete comments.
     * @principle Public read for comments, owner-only write.
     */
    match /posts/{postId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

    /**
     * @description Enforces access control for likes on posts.
     * @path /posts/{postId}/likes/{userId}
     * @allow (get, list) - Any user can read likes on posts.
     * @allow (create) - Any signed-in user can create a like.
     * @allow (delete) - Only the owner can delete the like
     * @deny (update) - No one can update a like.
     * @principle Public read for likes, open create for liking.
     */
    match /posts/{postId}/likes/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Allows public read access to challenges.
     * @path /challenges/{challengeId}
     * @allow (get, list) - Any user can read challenges.
     * @allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read access.
     */
    match /challenges/{challengeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to contests.
     * @path /contests/{contestId}
     * @allow (get, list) - Any user can read contests.
     * @allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Public read access.
     */
    match /contests/{contestId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to manifestation posts.
     * @path /manifestations/{manifestationId}
     * @allow (get, list) - Any user can read manifestation posts.
     * @allow (create) - Only the owner can create manifestations
     * @deny (update, delete) - Only the owner can update/delete manifestations.
     * @principle Public read access.
     */
    match /manifestations/{manifestationId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
    }

     /**
     * @description Enforces access control for comments on manifestation posts.
     * @path /manifestations/{manifestationId}/comments/{commentId}
     * @allow (get, list) - Any user can read comments on manifestation posts.
     * @allow (create) - Any signed-in user can create a comment.
     * @deny (update, delete) - Only the owner can update/delete comments.
     * @principle Public read for comments, owner-only write.
     */
    match /manifestations/{manifestationId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

      /**
     * @description Enforces access control for likes on manifestation posts.
     * @path /manifestations/{manifestationId}/likes/{userId}
     * @allow (get, list) - Any user can read likes on manifestation posts.
     * @allow (create) - Any signed-in user can create a like.
     * @allow (delete) - Only the owner can delete the like
     * @deny (update) - No one can update a like.
     * @principle Public read for likes, open create for liking.
     */
    match /manifestations/{manifestationId}/likes/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if isOwner(userId) && resource != null;
    }
  }
}