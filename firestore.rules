/**
  * @description This ruleset enforces a strict user-ownership model for user-specific data,
  *              while allowing public read access to certain top-level collections like deities, temples, stories, etc.
  *              User-generated content in communities is also generally public for reading.
  * @dataStructure The data is organized hierarchically, with user-specific data nested under /users/{userId}.
  *                Top-level collections store public content and metadata.
  * @keySecurityDecisions
  *   - Users can only access their own data under /users/{userId}.
  *   - Data consistency is enforced for user IDs in paths and documents.
  *   - Top-level collections are generally readable by everyone but writable only by owners.
  *   - Listing of user subcollections is restricted to the owner.
  *   - To improve security and performance, an ownership field ('ownerId', 'authorId', 'userId') is required
  *     on documents where owner-only writes are enforced.  Data is denormalized to avoid `get()` calls.
  */
 

 rules_version = '2';
 service cloud.firestore {
  match /databases/{database}/documents {
 

   /**
    * @description Secure user profiles. Only the authenticated user can read/write their own profile.
    * @path /users/{userId}
    * @allow (create, update, delete): if request.auth.uid == userId
    * @allow get, list: if request.auth.uid == userId
    * @deny (create, update, delete): if request.auth.uid != userId
    * @principle Enforces document ownership for all operations.
    */
   match /users/{userId} {
    function isOwner(userId) {
     return request.auth.uid == userId;
    }
 

    allow get, list: if isOwner(userId);
    allow create: if isOwner(userId) && request.resource.data.id == userId;
    allow update: if isOwner(userId) && resource.data.id == request.resource.data.id;
    allow delete: if isOwner(userId) && resource != null;
 

    /**
     * @description Tracks a user's progress in a specific contest.
     * @path /users/{userId}/contestProgress/{contestId}
     * @allow (create, update, delete): if request.auth.uid == userId
     * @allow get, list: if request.auth.uid == userId
     * @deny (create, update, delete): if request.auth.uid != userId
     * @principle Enforces document ownership for all operations.
     */
    match /contestProgress/{contestId} {
     allow get, list: if isOwner(userId);
     allow create: if isOwner(userId);
     allow update: if isOwner(userId) && resource != null;
     allow delete: if isOwner(userId) && resource != null;
    }
 

    /**
     * @description A subcollection storing the users who are following this user.
     * @path /users/{userId}/followers/{followerId}
     * @allow (create): if request.auth.uid == followerId
     * @allow get, list: if isOwner(userId);
     * @deny (create, update, delete): if request.auth.uid != followerId
     * @principle Enforces document ownership for all operations.
     */
    match /followers/{followerId} {
     allow get, list: if isOwner(userId);
     allow create: if request.auth.uid == followerId;
     allow update, delete: if false;
    }
 

    /**
     * @description A subcollection storing the users this user is following.
     * @path /users/{userId}/following/{followedId}
     * @allow (create): if request.auth.uid == userId
     * @allow get, list: if isOwner(userId);
     * @deny (create, update, delete): if request.auth.uid != userId
     * @principle Enforces document ownership for all operations.
     */
    match /following/{followedId} {
     allow get, list: if isOwner(userId);
     allow create: if isOwner(userId);
     allow update, delete: if false;
    }
 

    /**
     * @description A subcollection storing the channels this user is subscribed to.
     * @path /users/{userId}/subscriptions/{channelId}
     * @allow (create): if request.auth.uid == userId
     * @allow get, list: if isOwner(userId);
     * @deny (create, update, delete): if request.auth.uid != userId
     * @principle Enforces document ownership for all operations.
     */
    match /subscriptions/{channelId} {
     allow get, list: if isOwner(userId);
     allow create: if isOwner(userId);
     allow update, delete: if false;
    }
 

    /**
     * @description Secure user preferences. Only the authenticated user can read/write their own preferences.
     *              Uses a singleton document 'default'.
     * @path /users/{userId}/preferences/default
     * @allow (create, update, delete): if request.auth.uid == userId
     * @allow get: if request.auth.uid == userId
     * @deny (create, update, delete): if request.auth.uid != userId
     * @principle Enforces document ownership for all operations.
     */
    match /preferences/default {
     allow get: if isOwner(userId);
     allow create: if isOwner(userId);
     allow update: if isOwner(userId) && resource != null;
     allow delete: if isOwner(userId) && resource != null;
     allow list: if false;
    }
 

    /**
     * @description Secure user badges. Only the authenticated user can read/write their own badges.
     * @path /users/{userId}/badges/{badgeId}
     * @allow (create, update, delete): if request.auth.uid == userId
     * @allow get, list: if request.auth.uid == userId
     * @deny (create, update, delete): if request.auth.uid != userId
     */
    match /badges/{badgeId} {
     allow get, list: if isOwner(userId);
     allow create: if isOwner(userId);
     allow update: if isOwner(userId) && resource != null;
     allow delete: if isOwner(userId) && resource != null;
    }
 

    /**
     * @description Secure user bookmarks for temples. Only the authenticated user can read/write their own bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (create, update, delete): if request.auth.uid == userId
     * @allow get, list: if request.auth.uid == userId
     * @deny (create, update, delete): if request.auth.uid != userId
     */
    match /bookmarks/{bookmarkId} {
     allow get, list: if isOwner(userId);
     allow create: if isOwner(userId);
     allow update: if isOwner(userId) && resource != null;
     allow delete: if isOwner(userId) && resource != null;
    }
 

    /**
     * @description Secure user virtual offerings. Only the authenticated user can read/write their own offerings.
     * @path /users/{userId}/virtualOfferings/{offeringId}
     * @allow (create, update, delete): if request.auth.uid == userId
     * @allow get, list: if request.auth.uid == userId
     * @deny (create, update, delete): if request.auth.uid != userId
     */
    match /virtualOfferings/{offeringId} {
     allow get, list: if isOwner(userId);
     allow create: if isOwner(userId);
     allow update: if isOwner(userId) && resource != null;
     allow delete: if isOwner(userId) && resource != null;
    }
 

    /**
     * @description Secure user's shopping cart. Only the authenticated user can read/write their own cart.
     * @path /users/{userId}/cart/{productId}
     * @allow (create, update, delete): if request.auth.uid == userId
     * @allow get, list: if request.auth.uid == userId
     * @deny (create, update, delete): if request.auth.uid != userId
     */
    match /cart/{productId} {
     allow get, list: if isOwner(userId);
     allow create: if isOwner(userId);
     allow update: if isOwner(userId) && resource != null;
     allow delete: if isOwner(userId) && resource != null;
    }
 

    /**
     * @description Secure user-created playlists. Only the authenticated user can read/write their own playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create, update, delete): if request.auth.uid == userId
     * @allow get, list: if request.auth.uid == userId
     * @deny (create, update, delete): if request.auth.uid != userId
     */
    match /playlists/{playlistId} {
     allow get, list: if isOwner(userId);
     allow create: if isOwner(userId);
     allow update: if isOwner(userId) && resource != null;
     allow delete: if isOwner(userId) && resource != null;
    }
 

    /**
     * @description Secure user progress in community challenges. Only the authenticated user can read/write their own progress.
     * @path /users/{userId}/challenges/{challengeId}
     * @allow (create, update, delete): if request.auth.uid == userId
     * @allow get, list: if request.auth.uid == userId
     * @deny (create, update, delete): if request.auth.uid != userId
     */
    match /challenges/{challengeId} {
     allow get, list: if isOwner(userId);
     allow create: if isOwner(userId);
     allow update: if isOwner(userId) && resource != null;
     allow delete: if isOwner(userId) && resource != null;
    }
   }
 

   /**
    * @description Stores all user orders globally.
    * @path /orders/{orderId}
    * @allow get, list: if false;
    * @allow create, update, delete: if false;
    * @principle No access granted - could be used by backend functions
    */
   match /orders/{orderId} {
    allow get, list: if false;
    allow create, update, delete: if false;
   }
 

   /**
    * @description Stores all media on the platform (videos, audio, etc.).
    * @path /media/{mediaId}
    * @allow get, list: if true;
    * @allow create: if request.auth.uid == request.resource.data.userId;
    * @allow update: if resource.data.userId == request.auth.uid && resource != null;
    * @allow delete: if resource.data.userId == request.auth.uid && resource != null;
    * @principle Public read access, owner-only writes.
    */
   match /media/{mediaId} {
    allow get, list: if true;
    allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
    allow update: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
    allow delete: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
   }
 

   /**
    * @description Stores comments for a specific media item.
    * @path /media/{mediaId}/comments/{commentId}
    * @allow get, list: if true;
    * @allow create: if request.auth != null;
    * @allow update: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
    * @allow delete: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
    * @principle Public read access, owner-only writes.
    */
   match /media/{mediaId}/comments/{commentId} {
    allow get, list: if true;
    allow create: if request.auth != null;
    allow update: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
    allow delete: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
   }
 

   /**
    * @description Stores likes for a specific media item. Document ID is the user's UID.
    * @path /media/{mediaId}/likes/{userId}
    * @allow get, list: if true;
    * @allow create: if request.auth.uid == userId;
    * @allow update, delete: if false;
    * @principle Public read access, owner-only writes.
    */
   match /media/{mediaId}/likes/{userId} {
    allow get, list: if true;
    allow create: if request.auth.uid == userId;
    allow update, delete: if false;
   }
 

   /**
    * @description Stores all channels on the platform.
    * @path /channels/{channelId}
    * @allow get, list: if true;
    * @allow create: if request.auth.uid == request.resource.data.userId;
    * @allow update: if resource.data.userId == request.auth.uid && resource != null;
    * @allow delete: if resource.data.userId == request.auth.uid && resource != null;
    * @principle Public read access, owner-only writes.
    */
   match /channels/{channelId} {
    allow get, list: if true;
    allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
    allow update: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
    allow delete: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
   }
 

   /**
    * @description Subcollection to track subscribers of a channel.
    * @path /channels/{channelId}/subscribers/{userId}
    * @allow get, list: if true;
    * @allow create: if request.auth.uid == userId;
    * @allow update, delete: if false;
    * @principle Public read access, owner-only writes.
    */
   match /channels/{channelId}/subscribers/{userId} {
    allow get, list: if true;
    allow create: if request.auth.uid == userId;
    allow update, delete: if false;
   }
 

   /**
    * @description Stores all public or user-created playlists.
    * @path /playlists/{playlistId}
    * @allow get, list: if true;
    * @allow create: if request.auth != null && request.resource.data.creatorId == request.auth.uid;
    * @allow update: if request.auth != null && resource.data.creatorId == request.auth.uid && resource != null;
    * @allow delete: if request.auth != null && resource.data.creatorId == request.auth.uid && resource != null;
    * @principle Public read access, owner-only writes.
    */
   match /playlists/{playlistId} {
    allow get, list: if true;
    allow create: if request.auth != null && request.resource.data.creatorId == request.auth.uid;
    allow update: if request.auth != null && resource.data.creatorId == request.auth.uid && resource != null;
    allow delete: if request.auth != null && resource.data.creatorId == request.auth.uid && resource != null;
   }
 

   /**
    * @description Stores horoscopes generated for users.
    * @path /users/{userId}/horoscopes/{horoscopeId}
    * @allow get, list: if request.auth.uid == userId;
    * @allow create, update, delete: if false;
    * @principle Owner only reads
    */
   match /users/{userId}/horoscopes/{horoscopeId} {
    function isOwner(userId) {
     return request.auth.uid == userId;
    }
    allow get, list: if isOwner(userId);
    allow create, update, delete: if false;
   }
 

   /**
    * @description Stores information about Hindu deities.
    * @path /deities/{deityId}
    * @allow get, list: if true;
    * @allow create, update, delete: if false; // TODO: Add admin validation logic.
    * @principle Public read access, admin-only writes.
    */
   match /deities/{deityId} {
    allow get, list: if true;
    allow create, update, delete: if false; // TODO: Add admin validation logic.
   }
 

   /**
    * @description Stores all shops for the marketplace.
    * @path /shops/{shopId}
    * @allow get, list: if true;
    * @allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
    * @allow update: if request.auth != null && resource.data.ownerId == request.auth.uid && resource != null;
    * @allow delete: if request.auth != null && resource.data.ownerId == request.auth.uid && resource != null;
    * @principle Public read access, owner-only writes.
    */
   match /shops/{shopId} {
    allow get, list: if true;
    allow create: if request.auth != null && request.resource.data.ownerId == request.auth.uid;
    allow update: if request.auth != null && resource.data.ownerId == request.auth.uid && resource != null;
    allow delete: if request.auth != null && resource.data.ownerId == request.auth.uid && resource != null;
   }
 

   /**
    * @description Stores all products for the marketplace.
    * @path /products/{productId}
    * @allow get, list: if true;
    * @allow create, update, delete: if false; // TODO: Implement owner validation, potentially linked to shopId.
    * @principle Public read access, owner-only writes (but owner not yet defined)
    */
   match /products/{productId} {
    allow get, list: if true;
    allow create, update, delete: if false; // TODO: Implement owner validation, potentially linked to shopId.
   }
 

   /**
    * @description Stores all temple and pilgrimage data.
    * @path /temples/{templeId}
    * @allow get, list: if true;
    * @allow create, update, delete: if false; // TODO: Add admin validation logic.
    * @principle Public read access, admin-only writes.
    */
   match /temples/{templeId} {
    allow get, list: if true;
    allow create, update, delete: if false; // TODO: Add admin validation logic.
   }
 

   /**
    * @description Stores user reviews for a specific temple.
    * @path /temples/{templeId}/reviews/{reviewId}
    * @allow get, list: if true;
    * @allow create: if request.auth != null;
    * @allow update: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
    * @allow delete: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
    * @principle Public read access, owner-only writes.
    */
   match /temples/{templeId}/reviews/{reviewId} {
    allow get, list: if true;
    allow create: if request.auth != null;
    allow update: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
    allow delete: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
   }
 

   /**
    * @description Stores user posts for a specific temple.
    * @path /temples/{templeId}/posts/{postId}
    * @allow get, list: if true;
    * @allow create: if request.auth != null;
    * @allow update: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
    * @allow delete: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
    * @principle Public read access, owner-only writes.
    */
   match /temples/{templeId}/posts/{postId} {
    allow get, list: if true;
    allow create: if request.auth != null;
    allow update: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
    allow delete: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
   }
 

   /**
    * @description Stores mythological stories.
    * @path /stories/{storyId}
    * @allow get, list: if true;
    * @allow create, update, delete: if false; // TODO: Add admin validation logic.
    * @principle Public read access, admin-only writes.
    */
   match /stories/{storyId} {
    allow get, list: if true;
    allow create, update, delete: if false; // TODO: Add admin validation logic.
   }
 

   /**
    * @description Stores mythological heroes and characters.
    * @path /epicHeroes/{heroId}
    * @allow get, list: if true;
    * @allow create, update, delete: if false; // TODO: Add admin validation logic.
    * @principle Public read access, admin-only writes.
    */
   match /epicHeroes/{heroId} {
    allow get, list: if true;
    allow create, update, delete: if false; // TODO: Add admin validation logic.
   }
 

   /**
    * @description Stores guidelines for various rituals and poojas.
    * @path /rituals/{ritualId}
    * @allow get, list: if true;
    * @allow create, update, delete: if false; // TODO: Add admin validation logic.
    * @principle Public read access, admin-only writes.
    */
   match /rituals/{ritualId} {
    allow get, list: if true;
    allow create, update, delete: if false; // TODO: Add admin validation logic.
   }
 

   /**
    * @description Stores daily panchang data, with the document ID being the date (e.g., '2025-10-05').
    * @path /panchang/{date}
    * @allow get, list: if true;
    * @allow create, update, delete: if false; // TODO: Add admin validation logic.
    * @principle Public read access, admin-only writes.
    */
   match /panchang/{date} {
    allow get, list: if true;
    allow create, update, delete: if false; // TODO: Add admin validation logic.
   }
 

   /**
    * @description Stores details about cultural and religious festivals.
    * @path /festivals/{festivalId}
    * @allow get, list: if true;
    * @allow create, update, delete: if false; // TODO: Add admin validation logic.
    * @principle Public read access, admin-only writes.
    */
   match /festivals/{festivalId} {
    allow get, list: if true;
    allow create, update, delete: if false; // TODO: Add admin validation logic.
   }
 

   /**
    * @description Stores community groups.
    * @path /groups/{groupId}
    * @allow get, list: if true;
    * @allow create: if request.auth != null;
    * @allow update: if request.auth != null && resource != null;
    * @allow delete: if false;
    * @principle Public read access, limited write access.
    */
   match /groups/{groupId} {
    allow get, list: if true;
    allow create: if request.auth != null;
    allow update: if request.auth != null && resource != null;
    allow delete: if false;
 

    /**
     * @description Subcollection to track members of a group.
     * @path /groups/{groupId}/members/{userId}
     * @allow get, list: if true;
     * @allow create: if request.auth.uid == userId;
     * @allow update, delete: if false;
     * @principle Public read access, owner-only writes.
     */
    match /members/{userId} {
     allow get, list: if true;
     allow create: if request.auth.uid == userId;
     allow update, delete: if false;
    }
   }
 

   /**
    * @description Stores posts within a specific group.
    * @path /posts/{postId}
    * @allow get, list: if true;
    * @allow create: if request.auth != null;
    * @allow update: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
    * @allow delete: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
    * @principle Public read access, owner-only writes.
    */
   match /posts/{postId} {
    allow get, list: if true;
    allow create: if request.auth != null;
    allow update: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
    allow delete: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
 

    /**
     * @description Stores comments for a specific post within a group.
     * @path /posts/{postId}/comments/{commentId}
     * @allow get, list: if true;
     * @allow create: if request.auth != null;
     * @allow update: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
     * @allow delete: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
     * @principle Public read access, owner-only writes.
     */
    match /comments/{commentId} {
     allow get, list: if true;
     allow create: if request.auth != null;
     allow update: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
     allow delete: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
    }
 

    /**
     * @description Stores likes for a specific forum post within a group. Document ID is the user's UID.
     * @path /posts/{postId}/likes/{userId}
     * @allow get, list: if true;
     * @allow create: if request.auth.uid == userId;
     * @allow update, delete: if false;
     * @principle Public read access, owner-only writes.
     */
    match /likes/{userId} {
     allow get, list: if true;
     allow create: if request.auth.uid == userId;
     allow update, delete: if false;
    }
   }
 

   /**
    * @description Stores community challenges.
    * @path /challenges/{challengeId}
    * @allow get, list: if true;
    * @allow create, update, delete: if false; // TODO: Add admin validation logic.
    * @principle Public read access, admin-only writes.
    */
   match /challenges/{challengeId} {
    allow get, list: if true;
    allow create, update, delete: if false; // TODO: Add admin validation logic.
   }
 

   /**
    * @description Stores global chanting contests.
    * @path /contests/{contestId}
    * @allow get, list: if true;
    * @allow create, update, delete: if false; // TODO: Add admin validation logic.
    * @principle Public read access, admin-only writes.
    */
   match /contests/{contestId} {
    allow get, list: if true;
    allow create, update, delete: if false; // TODO: Add admin validation logic.
   }
 

   /**
    * @description Stores user-submitted manifestation techniques and stories.
    * @path /manifestations/{manifestationId}
    * @allow get, list: if true;
    * @allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
    * @allow update: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
    * @allow delete: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
    * @principle Public read access, owner-only writes.
    */
   match /manifestations/{manifestationId} {
    allow get, list: if true;
    allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
    allow update: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
    allow delete: if request.auth != null && resource.data.userId == request.auth.uid && resource != null;
 

    /**
     * @description Stores comments on a manifestation post.
     * @path /manifestations/{manifestationId}/comments/{commentId}
     * @allow get, list: if true;
     * @allow create: if request.auth != null;
     * @allow update: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
     * @allow delete: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
     * @principle Public read access, owner-only writes.
     */
    match /comments/{commentId} {
     allow get, list: if true;
     allow create: if request.auth != null;
     allow update: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
     allow delete: if request.auth != null && resource.data.authorId == request.auth.uid && resource != null;
    }
 

    /**
     * @description Stores likes for a manifestation post.
     * @path /manifestations/{manifestationId}/likes/{userId}
     * @allow get, list: if true;
     * @allow create: if request.auth.uid == userId;
     * @allow update, delete: if false;
     * @principle Public read access, owner-only writes.
     */
    match /likes/{userId} {
     allow get, list: if true;
     allow create: if request.auth.uid == userId;
     allow update, delete: if false;
    }
   }
  }
 }