/**
 * @file Firebase Security Rules for aaura App
 *
 * @description This ruleset enforces a user-ownership model for private data,
 * allows public read access to certain collections, and secures access to
 * collaborative content.
 *
 * @data_structure
 * - /users/{userId}: Stores user profiles and their associated data.
 * - /media/{mediaId}: Stores media content.
 * - /channels/{channelId}: Stores creator channels.
 * - /playlists/{playlistId}: Stores playlists.
 * - /deities/{deityId}: Stores deity information.
 * - /shops/{shopId}: Stores shop information.
 * - /products/{productId}: Stores product information.
 * - /temples/{templeId}: Stores temple information.
 * - /stories/{storyId}: Stores mythological stories.
 * - /epicHeroes/{heroId}: Stores epic heroes information.
 * - /rituals/{ritualId}: Stores ritual information.
 * - /panchang/{date}: Stores daily panchang information.
 * - /festivals/{festivalId}: Stores festival information.
 * - /groups/{groupId}: Stores community groups.
 * - /posts/{postId}: Stores community forum posts.
 * - /manifestations/{manifestationId}: Stores manifestation posts.
 *
 * @key_security_decisions
 * - User data is strictly controlled by the owning user.
 * - Public content (e.g., deities, temples) is readable by all.
 * - Write access to public content is restricted (typically owner-only).
 * - Listing of user subcollections is generally allowed for the owner.
 * - Schema validation is relaxed to allow for rapid prototyping.
 *
 * @denormalization_for_authorization
 *   - Ownership is enforced by comparing `request.auth.uid` to the `userId`
 *     in the document path or a dedicated `ownerId` field within the document.
 *     This avoids costly `get()` calls.
 *
 * @structural_segregation
 *   - Private user data is stored under the `/users/{userId}` path, while
 *     public content resides in top-level collections (e.g., `/media`).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to manage their own profile data.
     * @path /users/{userId}
     * @allow (create) User with matching ID can create their profile.
     * @allow (get, update, delete) User with matching ID can read, update, and delete their profile.
     * @deny (create) User cannot create a profile with a mismatched ID.
     * @deny (update, delete) Other users cannot update or delete this profile.
     * @principle Enforces user ownership for profile data.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if true;
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows users to manage their followers.
     * @path /users/{userId}/followers/{followerId}
     * @allow (create) User can add a follower if followerId matches their UID.
     * @allow (get, list) User can read the list of their followers.
     * @allow (delete) User can remove a follower if followerId matches their UID.
     * @deny (create, update, delete) Other users cannot manage this user's followers.
     * @principle Enforces user ownership for follower management.
     */
    match /users/{userId}/followers/{followerId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create: if request.auth.uid == followerId;
      allow update: if false;
      allow delete: if request.auth.uid == followerId;
    }

     /**
      * @description Allows users to manage their followings (users they follow).
      * @path /users/{userId}/following/{followedId}
      * @allow (create) User can follow another user if userId matches their UID.
      * @allow (get, list) User can see who they are following.
      * @allow (delete) User can unfollow another user if userId matches their UID.
      * @deny (create, update, delete) Other users cannot manage this user's followings.
      * @principle Enforces user ownership for followings management.
      */
    match /users/{userId}/following/{followedId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows users to manage their preferences.
     * @path /users/{userId}/preferences/default
     * @allow (get, update) User with matching ID can read and update their preferences.
     * @allow (create) User with matching ID can create their preferences.
     * @deny (create, update) Other users cannot create or update this user's preferences.
     * @principle Enforces user ownership for preference data.
     */
    match /users/{userId}/preferences/default {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Allows users to manage their awarded badges.
     * @path /users/{userId}/badges/{badgeId}
     * @allow (get, list) User with matching ID can read their badges.
     * @deny (create, update, delete) Only the system (admin) can award/manage badges.
     * @principle Restricts badge management to the system.
     */
    match /users/{userId}/badges/{badgeId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create, update, delete: if false;
    }

    /**
     * @description Allows users to manage their bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (create, get, list, delete) User with matching ID can manage their bookmarks.
     * @deny (create, update, delete) Other users cannot manage this user's bookmarks.
     * @principle Enforces user ownership for bookmark data.
     */
    match /users/{userId}/bookmarks/{bookmarkId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows users to manage their virtual offerings.
     * @path /users/{userId}/virtualOfferings/{offeringId}
     * @allow (create, get, list, delete) User with matching ID can manage their virtual offerings.
     * @deny (create, update, delete) Other users cannot manage this user's virtual offerings.
     * @principle Enforces user ownership for virtual offering data.
     */
    match /users/{userId}/virtualOfferings/{offeringId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows users to manage their cart items.
     * @path /users/{userId}/cart/{productId}
     * @allow (create, get, list, update, delete) User with matching ID can manage their cart items.
     * @deny (create, update, delete) Other users cannot manage this user's cart.
     * @principle Enforces user ownership for shopping cart data.
     */
    match /users/{userId}/cart/{productId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows users to manage their orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create, get, list) User with matching ID can read their orders.
     * @deny (update, delete) Orders should not be modifiable or deletable by the user after creation.
     * @principle Enforces user ownership for order data.
     */
    match /users/{userId}/orders/{orderId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update, delete: if false;
    }

    /**
     * @description Allows users to manage their playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create, get, list, delete) User with matching ID can manage their playlists.
     * @deny (create, update, delete) Other users cannot manage this user's playlists.
     * @principle Enforces user ownership for playlist data.
     */
    match /users/{userId}/playlists/{playlistId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows users to manage their challenges.
     * @path /users/{userId}/challenges/{challengeId}
     * @allow (create, get, list, update) User with matching ID can manage their challenges.
     * @deny (create, update, delete) Other users cannot manage this user's challenges.
     * @principle Enforces user ownership for challenge data.
     */
    match /users/{userId}/challenges/{challengeId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Allows public read access to media content.
     * @path /media/{mediaId}
     * @allow (get, list) Anyone can read media content.
     * @deny (create, update, delete) Only authorized users (e.g., admins, content creators) can modify media.
     * @principle Public read access with restricted writes.
     */
    match /media/{mediaId} {
        function isOwner(mediaId) {
            return request.auth != null && request.auth.uid == resource.data.userId;
        }
      allow get, list: if true;
      // CRITICAL: Media needs an `ownerId` or `authorId` field.
      allow create, update, delete: if request.auth.uid == request.resource.data.userId; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows comments on media content.
     * @path /media/{mediaId}/comments/{commentId}
     * @allow (create) Any signed-in user can create a comment.
     * @allow (get, list) Anyone can read comments.
     * @allow (update, delete) Only the comment's author can modify it.
     * @principle Signed-in users can comment, and authors can manage their own comments.
     */
    match /media/{mediaId}/comments/{commentId} {
        function isOwner(commentId) {
            return request.auth != null && request.auth.uid == resource.data.authorId;
        }
      allow get, list: if true;
      allow create: if request.auth != null;
      allow update: if request.auth.uid == resource.data.authorId;
      allow delete: if request.auth.uid == resource.data.authorId;
    }

    /**
     * @description Allows users to like media content.
     * @path /media/{mediaId}/likes/{userId}
     * @allow (create, get, list, delete) User with matching ID can like/unlike the media.
     * @deny (create, update, delete) Other users cannot manage this user's likes.
     */
     match /media/{mediaId}/likes/{userId} {
        function isOwner(userId) {
          return request.auth != null && request.auth.uid == userId;
        }
        allow get, list: if true;
        allow create: if isOwner(userId);
        allow update: if false;
        allow delete: if isOwner(userId);
     }

    /**
     * @description Allows public read access to channels.
     * @path /channels/{channelId}
     * @allow (get, list) Anyone can read channel content.
     * @deny (create, update, delete) Only the channel owner or admin can modify channel data.
     * @principle Public read access with restricted writes.
     */
    match /channels/{channelId} {
      function isOwner(channelId) {
        return request.auth != null && request.auth.uid == resource.data.userId;
      }
      allow get, list: if true;
      allow create, update, delete: if request.auth.uid == request.resource.data.userId; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to playlists.
     * @path /playlists/{playlistId}
     * @allow (get, list) Anyone can read playlist content.
     * @deny (create, update, delete) Only the playlist owner or admin can modify playlist data.
     * @principle Public read access with restricted writes.
     */
    match /playlists/{playlistId} {
      function isOwner(playlistId) {
        return request.auth != null && request.auth.uid == resource.data.creatorId;
      }
      allow get, list: if true;
      allow create, update, delete: if request.auth.uid == request.resource.data.creatorId; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows users to read their own horoscopes.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (get, list) User with matching ID can read their horoscopes.
     * @deny (create, update, delete) Only the system can generate/manage horoscopes.
     * @principle Restricts horoscope management to the system.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to deity information.
     * @path /deities/{deityId}
     * @allow (get, list) Anyone can read deity information.
     * @deny (create, update, delete) Only authorized users (e.g., admins) can modify deity data.
     * @principle Public read access with restricted writes.
     */
    match /deities/{deityId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to shop information.
     * @path /shops/{shopId}
     * @allow (get, list) Anyone can read shop information.
     * @deny (create, update, delete) Only the shop owner can modify shop data.
     * @principle Public read access with restricted writes.
     */
    match /shops/{shopId} {
      function isOwner(shopId) {
        return request.auth != null && request.auth.uid == resource.data.ownerId;
      }
      allow get, list: if true;
      allow create, update, delete: if request.auth.uid == request.resource.data.ownerId; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to product information.
     * @path /products/{productId}
     * @allow (get, list) Anyone can read product information.
     * @deny (create, update, delete) Only the shop owner (via shop ID) can modify product data.
     * @principle Public read access with restricted writes.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to temple information.
     * @path /temples/{templeId}
     * @allow (get, list) Anyone can read temple information.
     * @deny (create, update, delete) Only authorized users (e.g., admins) can modify temple data.
     * @principle Public read access with restricted writes.
     */
    match /temples/{templeId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows users to submit reviews for temples.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (create) Any signed-in user can create a review.
     * @allow (get, list) Anyone can read reviews.
     * @allow (update, delete) Only the review's author can modify it.
     * @principle Signed-in users can review, and authors can manage their own reviews.
     */
    match /temples/{templeId}/reviews/{reviewId} {
      function isOwner(reviewId) {
        return request.auth != null && request.auth.uid == resource.data.userId;
      }
      allow get, list: if true;
      allow create: if request.auth != null;
      allow update: if request.auth.uid == resource.data.userId;
      allow delete: if request.auth.uid == resource.data.userId;
    }

    /**
     * @description Allows users to create posts within a temple's community forum.
     * @path /temples/{templeId}/posts/{postId}
     * @allow (create) Any signed-in user can create a post in the temple forum.
     * @allow (get, list) Anyone can read posts in the temple forum.
     * @allow (update, delete) Only the post's author can modify it.
     * @principle Signed-in users can post, and authors can manage their own posts.
     */
    match /temples/{templeId}/posts/{postId} {
      function isOwner(postId) {
        return request.auth != null && request.auth.uid == resource.data.authorId;
      }
      allow get, list: if true;
      allow create: if request.auth != null;
      allow update: if request.auth.uid == resource.data.authorId;
      allow delete: if request.auth.uid == resource.data.authorId;
    }

    /**
     * @description Allows public read access to stories.
     * @path /stories/{storyId}
     * @allow (get, list) Anyone can read story content.
     * @deny (create, update, delete) Only authorized users (e.g., admins, content creators) can modify stories.
     * @principle Public read access with restricted writes.
     */
    match /stories/{storyId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to epic heroes.
     * @path /epicHeroes/{heroId}
     * @allow (get, list) Anyone can read epic hero content.
     * @deny (create, update, delete) Only authorized users (e.g., admins, content creators) can modify epic heroes.
     * @principle Public read access with restricted writes.
     */
    match /epicHeroes/{heroId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to rituals.
     * @path /rituals/{ritualId}
     * @allow (get, list) Anyone can read ritual content.
     * @deny (create, update, delete) Only authorized users (e.g., admins, content creators) can modify rituals.
     * @principle Public read access with restricted writes.
     */
    match /rituals/{ritualId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to panchang data.
     * @path /panchang/{date}
     * @allow (get, list) Anyone can read panchang data.
     * @deny (create, update, delete) Only authorized users (e.g., admins) can modify panchang data.
     * @principle Public read access with restricted writes.
     */
    match /panchang/{date} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to festivals.
     * @path /festivals/{festivalId}
     * @allow (get, list) Anyone can read festival content.
     * @deny (create, update, delete) Only authorized users (e.g., admins, content creators) can modify festivals.
     * @principle Public read access with restricted writes.
     */
    match /festivals/{festivalId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

     /**
      * @description Allows public read access to community groups.
      * @path /groups/{groupId}
      * @allow (get, list) Anyone can read group content.
      * @deny (create, update, delete) Only authorized users (e.g., admins, group owners) can modify group data.
      * @principle Public read access with restricted writes.
      */
    match /groups/{groupId} {
        allow get, list: if true;
        allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

     /**
      * @description Allows users to join and leave community groups.
      * @path /groups/{groupId}/members/{userId}
      * @allow (create, get, list, delete) User with matching ID can manage their membership.
      * @deny (create, update, delete) Other users cannot manage this user's membership.
      * @principle Enforces user ownership for group membership.
      */
    match /groups/{groupId}/members/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isOwner(userId);
    }

    /**
     * @description Allows users to create posts within a community group.
     * @path /posts/{postId}
     * @allow (create) Any signed-in user can create a post in the group.
     * @allow (get, list) Anyone can read posts in the group.
     * @allow (update, delete) Only the post's author can modify it.
     * @principle Signed-in users can post, and authors can manage their own posts.
     */
    match /posts/{postId} {
      function isOwner(postId) {
        return request.auth != null && request.auth.uid == resource.data.authorId;
      }
      allow get, list: if true;
      allow create: if request.auth != null;
      allow update: if request.auth.uid == resource.data.authorId;
      allow delete: if request.auth.uid == resource.data.authorId;
    }

    /**
     * @description Allows comments on community posts.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (create) Any signed-in user can create a comment.
     * @allow (get, list) Anyone can read comments.
     * @allow (update, delete) Only the comment's author can modify it.
     * @principle Signed-in users can comment, and authors can manage their own comments.
     */
    match /posts/{postId}/comments/{commentId} {
      function isOwner(commentId) {
        return request.auth != null && request.auth.uid == resource.data.authorId;
      }
      allow get, list: if true;
      allow create: if request.auth != null;
      allow update: if request.auth.uid == resource.data.authorId;
      allow delete: if request.auth.uid == resource.data.authorId;
    }

    /**
     * @description Allows users to like posts.
     * @path /posts/{postId}/likes/{userId}
     * @allow (create, get, list, delete) User with matching ID can like/unlike the post.
     * @deny (create, update, delete) Other users cannot manage this user's likes.
     */
     match /posts/{postId}/likes/{userId} {
        function isOwner(userId) {
          return request.auth != null && request.auth.uid == userId;
        }
        allow get, list: if true;
        allow create: if isOwner(userId);
        allow update: if false;
        allow delete: if isOwner(userId);
     }

    /**
     * @description Allows public read access to challenges.
     * @path /challenges/{challengeId}
     * @allow (get, list) Anyone can read challenge content.
     * @deny (create, update, delete) Only authorized users (e.g., admins, content creators) can modify challenges.
     * @principle Public read access with restricted writes.
     */
    match /challenges/{challengeId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

     /**
      * @description Allows users to share their manifestation techniques and stories.
      * @path /manifestations/{manifestationId}
      * @allow (create) Any signed-in user can create a manifestation post.
      * @allow (get, list) Anyone can read manifestation posts.
      * @allow (update, delete) Only the post's author can modify it.
      * @principle Signed-in users can post, and authors can manage their own posts.
      */
    match /manifestations/{manifestationId} {
      function isOwner(manifestationId) {
        return request.auth != null && request.auth.uid == resource.data.userId;
      }
      allow get, list: if true;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      allow update: if request.auth.uid == resource.data.userId;
      allow delete: if request.auth.uid == resource.data.userId;
    }

    /**
     * @description Allows comments on manifestation posts.
     * @path /manifestations/{manifestationId}/comments/{commentId}
     * @allow (create) Any signed-in user can create a comment.
     * @allow (get, list) Anyone can read comments.
     * @allow (update, delete) Only the comment's author can modify it.
     * @principle Signed-in users can comment, and authors can manage their own comments.
     */
    match /manifestations/{manifestationId}/comments/{commentId} {
      function isOwner(commentId) {
        return request.auth != null && request.auth.uid == resource.data.authorId;
      }
      allow get, list: if true;
      allow create: if request.auth != null;
      allow update: if request.auth.uid == resource.data.authorId;
      allow delete: if request.auth.uid == resource.data.authorId;
    }

    /**
     * @description Allows users to like manifestation posts.
     * @path /manifestations/{manifestationId}/likes/{userId}
     * @allow (create, get, list, delete) User with matching ID can like/unlike the manifestation.
     * @deny (create, update, delete) Other users cannot manage this user's likes.
     */
     match /manifestations/{manifestationId}/likes/{userId} {
        function isOwner(userId) {
          return request.auth != null && request.auth.uid == userId;
        }
        allow get, list: if true;
        allow create: if isOwner(userId);
        allow update: if false;
        allow delete: if isOwner(userId);
     }
  }
}