/**
 * @fileoverview Firestore Security Rules for the Aaura app.
 *
 * Core Philosophy:
 * This ruleset prioritizes user data ownership and restricts unauthorized access.
 * Users have full control over their profile data and associated subcollections.
 * Public content is generally readable by all, but write access is strictly controlled.
 *
 * Data Structure:
 * - User-specific data is nested under `/users/{userId}`.
 * - Top-level collections (e.g., `/deities`, `/stories`, `/temples`) store public content.
 * - Social features (likes, comments) are implemented using subcollections for scalability.
 *
 * Key Security Decisions:
 * - Users can only write to their own user document and associated subcollections.
 * - Listing all users is disallowed.
 * - Public content collections are readable by all.
 * - Write operations are generally restricted to authorized users (e.g., content creators).
 * - Data consistency is enforced for crucial relational fields (e.g., userId).
 *
 * Denormalization for Authorization:
 * - Ownership checks rely on denormalized `userId` or `authorId` fields within documents.
 * - This avoids costly `get()` calls to separate user documents.
 *
 * Structural Segregation:
 * - Private user data is stored under `/users/{userId}`, while public content is stored in top-level collections.
 * - This simplifies read operations and enhances security for list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @path N/A
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     * @path N/A
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the existing owner of the resource.
     * @path N/A
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Helper function to check if a post exists
     * @path N/A
     */
    function postExists(postId) {
      return exists(/databases/$(database)/documents/posts/$(postId));
    }

    /**
     * @description Helper function to check valid context for posts
     * @path N/A
     */
    function isValidContext() {
      return request.resource.data.contextType in ['group', 'temple', 'channel'] &&
             exists(/databases/$(database)/documents/$(request.resource.data.contextType + 's')/$(request.resource.data.contextId));
    }

    /**
     * @description Enforces access control for user profiles.
     * @path /users/{userId}
     * @allow (read) Authenticated user can read anyone's profile
     * @allow (write) Authenticated user can write their own profile (create/update/delete)
     * @deny (write) Authenticated user cannot write another user's profile
     * @principle Enforces user-ownership for profile data.
     */
    match /users/{userId} {
      allow get: if true;
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);

      /**
       * @description Enforces access control for user contest progress.
       * @path /users/{userId}/contestProgress/{contestId}
       * @allow (read) Authenticated user can read their contest progress
       * @allow (write) Authenticated user can write their own contest progress (create/update/delete)
       * @deny (write) Authenticated user cannot write another user's contest progress
       * @principle Enforces user-ownership for profile data.
       */
       match /contestProgress/{contestId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Enforces access control for user followers.
       * @path /users/{userId}/followers/{followerId}
       * @allow (read) Authenticated user can read their followers
       * @allow (write) Authenticated user can write their own followers (create/update/delete)
       * @deny (write) Authenticated user cannot write another user's followers
       * @principle Enforces user-ownership for social graph data.
       */
      match /followers/{followerId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Enforces access control for user following.
       * @path /users/{userId}/following/{followedId}
       * @allow (read) Authenticated user can read their following
       * @allow (write) Authenticated user can write their own following (create/update/delete)
       * @deny (write) Authenticated user cannot write another user's following
       * @principle Enforces user-ownership for social graph data.
       */
      match /following/{followedId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Enforces access control for user subscriptions.
       * @path /users/{userId}/subscriptions/{channelId}
       * @allow (read) Authenticated user can read their subscriptions
       * @allow (write) Authenticated user can write their own subscriptions (create/update/delete)
       * @deny (write) Authenticated user cannot write another user's subscriptions
       * @principle Enforces user-ownership for subscription data.
       */
      match /subscriptions/{channelId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Enforces access control for user preferences.
       * @path /users/{userId}/preferences/default
       * @allow (read) Authenticated user can read their preferences
       * @allow (write) Authenticated user can write their own preferences (create/update/delete)
       * @deny (write) Authenticated user cannot write another user's preferences
       * @principle Enforces user-ownership for preference data.
       */
      match /preferences/default {
        allow get: if isOwner(userId);
        allow list: if false;
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Enforces access control for user badges.
       * @path /users/{userId}/badges/{badgeId}
       * @allow (read) Authenticated user can read their badges
       * @allow (write) Authenticated user can write their own badges (create/update/delete)
       * @deny (write) Authenticated user cannot write another user's badges
       * @principle Enforces user-ownership for badge data.
       */
      match /badges/{badgeId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Enforces access control for user bookmarks.
       * @path /users/{userId}/bookmarks/{bookmarkId}
       * @allow (read) Authenticated user can read their bookmarks
       * @allow (write) Authenticated user can write their own bookmarks (create/update/delete)
       * @deny (write) Authenticated user cannot write another user's bookmarks
       * @principle Enforces user-ownership for bookmark data.
       */
      match /bookmarks/{bookmarkId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Enforces access control for user virtual offerings.
       * @path /users/{userId}/virtualOfferings/{offeringId}
       * @allow (read) Authenticated user can read their virtual offerings
       * @allow (write) Authenticated user can write their own virtual offerings (create/update/delete)
       * @deny (write) Authenticated user cannot write another user's virtual offerings
       * @principle Enforces user-ownership for virtual offering data.
       */
      match /virtualOfferings/{offeringId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Enforces access control for user cart items.
       * @path /users/{userId}/cart/{productId}
       * @allow (read) Authenticated user can read their cart items
       * @allow (write) Authenticated user can write their own cart items (create/update/delete)
       * @deny (write) Authenticated user cannot write another user's cart items
       * @principle Enforces user-ownership for cart item data.
       */
      match /cart/{productId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Enforces access control for user playlists.
       * @path /users/{userId}/playlists/{playlistId}
       * @allow (read) Authenticated user can read their playlists
       * @allow (write) Authenticated user can write their own playlists (create/update/delete)
       * @deny (write) Authenticated user cannot write another user's playlists
       * @principle Enforces user-ownership for playlist data.
       */
      match /playlists/{playlistId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Enforces access control for user challenges.
       * @path /users/{userId}/challenges/{challengeId}
       * @allow (read) Authenticated user can read their challenges
       * @allow (write) Authenticated user can write their own challenges (create/update/delete)
       * @deny (write) Authenticated user cannot write another user's challenges
       * @principle Enforces user-ownership for challenge data.
       */
      match /challenges/{challengeId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }

       /**
        * @description Enforces access control for user horoscopes.
        * @path /users/{userId}/horoscopes/{horoscopeId}
        * @allow (read) Authenticated user can read their horoscopes
        * @allow (write) Authenticated user can write their own horoscopes (create/update/delete)
        * @deny (write) Authenticated user cannot write another user's horoscopes
        * @principle Enforces user-ownership for horoscope data.
        */
      match /horoscopes/{horoscopeId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
      }
    }

    /**
     * @description Enforces access control for orders.
     * @path /orders/{orderId}
     * @allow (read) Authenticated user can read orders
     * @allow (write) Authenticated user can write orders (create/update/delete)
     * @deny (write) No restriction on orders
     * // TODO: Add owner validation once the schema is updated with an ownership field.
     */
    match /orders/{orderId} {
      allow get: if isSignedIn();
      allow list: if false; // Listing orders needs more specific role-based logic
      allow create: if isSignedIn();  // TODO: Add validation to ensure userId matches auth.uid
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces access control for media.
     * @path /media/{mediaId}
     * @allow (read) Any user can read media
     * @allow (write) Authenticated user can write their own media (create/update/delete)
     * @deny (write) Authenticated user cannot write another user's media
     * @principle Enforces user-ownership for media data.
     */
    match /media/{mediaId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);

      /**
       * @description Enforces access control for media comments.
       * @path /media/{mediaId}/comments/{commentId}
       * @allow (read) Any user can read comments
       * @allow (write) Authenticated user can write their own comments (create/update/delete)
       */
      match /comments/{commentId} {
          allow get: if true;
          allow list: if true;
          allow create: if isSignedIn() &&
                        request.resource.data.authorId == request.auth.uid &&
                        request.resource.data.contentId == mediaId &&
                        request.resource.data.contentType == 'media' &&
                        request.resource.data.text is string &&
                        request.resource.data.text.size() > 0 &&
                        exists(/databases/$(database)/documents/media/$(mediaId));
          allow update: if isExistingOwner(resource.data.authorId);
          allow delete: if isExistingOwner(resource.data.authorId);
        }


       /**
        * @description Enforces access control for media likes.
        * @path /media/{mediaId}/likes/{userId}
        * @allow (read) Any user can read likes
        * @allow (write) Authenticated user can write their own likes (create/update/delete)
        * @deny (write) Authenticated user cannot write another user's likes
        * @principle Enforces user-ownership for like data.
        */
        match /likes/{userId} {
          allow get: if true;
          allow list: if true;
          allow create: if isSignedIn() && request.auth.uid == userId && exists(/databases/$(database)/documents/media/$(mediaId));
          allow update: if false; // Likes are generally not updated.
          allow delete: if isSignedIn() && request.auth.uid == userId && exists(/databases/$(database)/documents/media/$(mediaId));
        }
    }

    /**
     * @description Enforces access control for channels.
     * @path /channels/{channelId}
     * @allow (read) Any user can read channels
     * @allow (write) No user can write channels
     */
    match /channels/{channelId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.

      /**
       * @description Enforces access control for channel subscribers.
       * @path /channels/{channelId}/subscribers/{userId}
       */
      match /subscribers/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
        allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
        allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      }
    }

    /**
     * @description Enforces access control for playlists.
     * @path /playlists/{playlistId}
     * @allow (read) Any user can read playlists
     */
    match /playlists/{playlistId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces access control for deities.
     * @path /deities/{deityId}
     * @allow (read) Any user can read deities
     */
    match /deities/{deityId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces access control for shops.
     * @path /shops/{shopId}
     *  // TODO: Add owner validation once the schema is updated with an ownership field.
     */
    match /shops/{shopId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource.data.ownerId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.ownerId == request.auth.uid;
    }

    /**
     * @description Enforces access control for products.
     * @path /products/{productId}
     * @allow (read) Any user can read products
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
       allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces access control for temples.
     * @path /temples/{templeId}
     * @allow (read) Any user can read temples
     */
    match /temples/{templeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.

       /**
        * @description Enforces access control for temple posts.
        * @path /temples/{templeId}/posts/{postId}
        * @allow (read) Any user can read posts
        */
      match /posts/{postId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() &&
                       request.resource.data.authorId == request.auth.uid &&
                       isValidContext();
        allow update: if isExistingOwner(resource.data.authorId);
        allow delete: if isExistingOwner(resource.data.authorId);
      }

      /**
       * @description Enforces access control for temple reviews.
       * @path /temples/{templeId}/reviews/{reviewId}
       */
      match /reviews/{reviewId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn(); // TODO: Add owner validation once the schema is updated with an ownership field.
        allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
        allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      }
    }

    /**
     * @description Enforces access control for stories.
     * @path /stories/{storyId}
     * @allow (read) Any user can read stories
     */
    match /stories/{storyId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces access control for epic heroes.
     * @path /epicHeroes/{heroId}
     * @allow (read) Any user can read epic heroes
     */
    match /epicHeroes/{heroId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces access control for rituals.
     * @path /rituals/{ritualId}
     * @allow (read) Any user can read rituals
     */
    match /rituals/{ritualId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces access control for panchang.
     * @path /panchang/{date}
     * @allow (read) Any user can read panchang
     */
    match /panchang/{date} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces access control for festivals.
     * @path /festivals/{festivalId}
     * @allow (read) Any user can read festivals
     */
    match /festivals/{festivalId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces access control for groups.
     * @path /groups/{groupId}
     */
    match /groups/{groupId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource.data.creatorId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.creatorId == request.auth.uid;

       /**
        * @description Enforces access control for group members.
        * @path /groups/{groupId}/members/{userId}
        */
      match /members/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
        allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
        allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      }
    }

    /**
     * @description Enforces access control for posts.
     * @path /posts/{postId}
     */
    match /posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() &&
                     request.resource.data.authorId == request.auth.uid &&
                     isValidContext();
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);

       /**
        * @description Enforces access control for post comments.
        * @path /posts/{postId}/comments/{commentId}
        */
      match /comments/{commentId} {
          allow get: if true;
          allow list: if true;
          allow create: if isSignedIn() &&
                        request.resource.data.authorId == request.auth.uid &&
                        request.resource.data.contentId == postId &&
                        request.resource.data.contentType == 'post' &&
                        request.resource.data.text is string &&
                        request.resource.data.text.size() > 0 &&
                        postExists(postId);
          allow update: if isExistingOwner(resource.data.authorId);
          allow delete: if isExistingOwner(resource.data.authorId);
        }

       /**
        * @description Enforces access control for post likes.
        * @path /posts/{postId}/likes/{userId}
        */
        match /likes/{userId} {
          allow get: if true;
          allow list: if true;
          allow create: if isSignedIn() && request.auth.uid == userId && postExists(postId);
          allow update: if false; // Likes are generally not updated.
          allow delete: if isSignedIn() && request.auth.uid == userId && postExists(postId);
        }
    }

    /**
     * @description Enforces access control for challenges.
     * @path /challenges/{challengeId}
     */
    match /challenges/{challengeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces access control for contests.
     * @path /contests/{contestId}
     */
    match /contests/{contestId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if false; // Contests are generally not deleted.
    }

    /**
     * @description Enforces access control for manifestations.
     * @path /manifestations/{manifestationId}
     */
    match /manifestations/{manifestationId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);

      /**
       * @description Enforces access control for manifestation comments.
       * @path /manifestations/{manifestationId}/comments/{commentId}
       */
      match /comments/{commentId} {
          allow get: if true;
          allow list: if true;
          allow create: if isSignedIn() &&
                        request.resource.data.authorId == request.auth.uid &&
                        request.resource.data.contentId == manifestationId &&
                        request.resource.data.contentType == 'manifestation' &&
                        request.resource.data.text is string &&
                        request.resource.data.text.size() > 0 &&
                        exists(/databases/$(database)/documents/manifestations/$(manifestationId));
          allow update: if isExistingOwner(resource.data.authorId);
          allow delete: if isExistingOwner(resource.data.authorId);
        }

        /**
         * @description Enforces access control for manifestation likes.
         * @path /manifestations/{manifestationId}/likes/{userId}
         */
        match /likes/{userId} {
          allow get: if true;
          allow list: if true;
          allow create: if isSignedIn() && request.auth.uid == userId && exists(/databases/$(database)/documents/manifestations/$(manifestationId));
          allow update: if false; // Likes are generally not updated.
          allow delete: if isSignedIn() && request.auth.uid == userId && exists(/databases/$(database)/documents/manifestations/$(manifestationId));
        }
    }
  }
}