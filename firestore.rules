/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for personal data and allows public read access for certain content types.
 *
 * Data Structure:
 * - User-specific data (profiles, preferences, bookmarks, etc.) is nested under `/users/{userId}`.
 * - Public content (media, deities, temples, etc.) resides in top-level collections.
 * - Likes are stored as subcollections to their respective entities.
 *
 * Key Security Decisions:
 * - Users can only access their own data.
 * - Public content is readable by everyone, but write access is restricted.
 * - Listing of user subcollections (followers, following, etc.) is allowed only by the owner.
 * - Data validation is limited to relational integrity (ownership) and critical fields.
 *
 * Denormalization for Authorization:
 *  Likes: Likes are stored in subcollections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if the user is signed in
    function isSignedIn() {
      return request.auth != null;
    }

    // Helper function to check if the authenticated user is the owner of the resource
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    // Helper function to check if the authenticated user is the existing owner of the resource
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Secure user profiles. Users can only read/write their own profile data.
     * @path /users/{userId}
     * @allow (create) - User with matching UID can create their profile.
     * @allow (get, update, delete) - User with matching UID can access/modify their profile.
     * @deny (create, get, update, delete) - Any other user cannot access/modify another user's profile.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is not permitted

      allow create: if isOwner(userId) && request.resource.data.id == request.auth.uid;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id; // Enforce immutability
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure followers subcollection.  Owner can manage their followers.
     * @path /users/{userId}/followers/{followerId}
     * @allow (create) - User with matching UID can create their follower list.
     * @allow (get, update, delete) - User with matching UID can access/modify their follower list.
     * @deny (create, get, update, delete) - Any other user cannot access/modify another user's follower list.
     * @principle Enforces document ownership for user's followers list.
     */
    match /users/{userId}/followers/{followerId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure following subcollection. Owner can manage who they are following.
     * @path /users/{userId}/following/{followedId}
     * @allow (create) - User with matching UID can create their following list.
     * @allow (get, update, delete) - User with matching UID can access/modify their following list.
     * @deny (create, get, update, delete) - Any other user cannot access/modify another user's following list.
     * @principle Enforces document ownership for user's following list.
     */
    match /users/{userId}/following/{followedId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user preferences. Users can only access their own preferences.
     * @path /users/{userId}/preferences/default
     * @allow (get, update) - User with matching UID can access/modify their preferences.
     * @deny (create, get, update, delete) - Any other user cannot access/modify another user's preferences.
     * @principle Enforces document ownership for user preferences.
     */
    match /users/{userId}/preferences/default {
      allow get: if isOwner(userId);
      allow list: if false;

      allow create: if false; // Singleton document, creation not allowed via client.
      allow update: if isExistingOwner(userId);
      allow delete: if false;
    }

    /**
     * @description Secure user badges. Users can only access their own badges.
     * @path /users/{userId}/badges/{badgeId}
     * @allow (create, get, update, delete) - User with matching UID can access/modify their badges.
     * @deny (create, get, update, delete) - Any other user cannot access/modify another user's badges.
     * @principle Enforces document ownership for user badges.
     */
    match /users/{userId}/badges/{badgeId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user bookmarks. Users can only access their own bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (create, get, update, delete) - User with matching UID can access/modify their bookmarks.
     * @deny (create, get, update, delete) - Any other user cannot access/modify another user's bookmarks.
     * @principle Enforces document ownership for user bookmarks.
     */
    match /users/{userId}/bookmarks/{bookmarkId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user virtual offerings. Users can only access their own offerings.
     * @path /users/{userId}/virtualOfferings/{offeringId}
     * @allow (create, get, update, delete) - User with matching UID can access/modify their offerings.
     * @deny (create, get, update, delete) - Any other user cannot access/modify another user's offerings.
     * @principle Enforces document ownership for user virtual offerings.
     */
    match /users/{userId}/virtualOfferings/{offeringId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user's shopping cart.
     * @path /users/{userId}/cart/{productId}
     * @allow (create, get, update, delete) - User with matching UID can access/modify their cart.
     * @deny (create, get, update, delete) - Any other user cannot access/modify another user's cart.
     * @principle Enforces document ownership for user's cart.
     */
    match /users/{userId}/cart/{productId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user orders. Users can only access their own orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create, get, update, delete) - User with matching UID can access/modify their orders.
     * @deny (create, get, update, delete) - Any other user cannot access/modify another user's orders.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user playlists.
     * @path /users/{userId}/playlists/{playlistId}
     */
     match /users/{userId}/playlists/{playlistId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure user challenge progress.
     * @path /users/{userId}/challenges/{challengeId}
     */
    match /users/{userId}/challenges/{challengeId} {
        allow get, list: if isOwner(userId);

        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure media content. Public read, owner-only writes.
     * @path /media/{mediaId}
     * @allow (get, list) - Anyone can read media content.
     * @allow (create) - Only the authenticated user who is the author of this media can create the media.
     * @allow (update, delete) - Only the authenticated user who is the author of this media can update/delete.
     * @deny (create, update, delete) - Any other user cannot create/modify another user's media.
     * @principle Public read access with owner-only writes.
     */
    match /media/{mediaId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
    }

    /**
     * @description Secure comments for media items. Public read, owner-only writes.
     * @path /media/{mediaId}/comments/{commentId}
     * @allow (get, list) - Anyone can read comments on media items.
     * @allow (create) - Only the authenticated user who is the author of this comment can create the comment.
     * @allow (update, delete) - Only the authenticated user who is the author of this comment can update/delete.
     * @deny (create, update, delete) - Any other user cannot create/modify another user's comments.
     * @principle Public read access with owner-only writes.
     */
    match /media/{mediaId}/comments/{commentId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

    /**
     * @description Secure likes for media items.
     * @path /media/{mediaId}/likes/{userId}
     * @allow (create, get, update, delete) - User with matching UID can access/modify their like.
     * @deny (create, get, update, delete) - Any other user cannot access/modify another user's like.
     * @principle Enforces document ownership for user likes.
     */
    match /media/{mediaId}/likes/{userId} {
      allow get, list: if true; // Publicly readable to show like count.

      allow create: if isSignedIn() && userId == request.auth.uid; // User can like
      allow update: if false; // Likes are idempotent
      allow delete: if isSignedIn() && userId == request.auth.uid && resource != null; //User can unlike
    }

    /**
     * @description Secure channel content. Public read, owner-only writes.
     * @path /channels/{channelId}
     * @allow (get, list) - Anyone can read channel content.
     * @allow (create) - Only the authenticated user who is the author of this channel can create the channel.
     * @allow (update, delete) - Only the authenticated user who is the author of this channel can update/delete.
     * @deny (create, update, delete) - Any other user cannot create/modify another user's channel.
     * @principle Public read access with owner-only writes.
     */
    match /channels/{channelId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
    }

    /**
     * @description Secure playlist content. Public read, owner-only writes.
     * @path /playlists/{playlistId}
     * @allow (get, list) - Anyone can read playlist content.
     * @allow (create) - Only the authenticated user who is the author of this playlist can create the playlist.
     * @allow (update, delete) - Only the authenticated user who is the author of this playlist can update/delete.
     * @deny (create, update, delete) - Any other user cannot create/modify another user's playlist.
     * @principle Public read access with owner-only writes.
     */
    match /playlists/{playlistId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.creatorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.creatorId == request.auth.uid && resource != null;
    }

    /**
     * @description Secure horoscope content. Users can only access their own horoscopes.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (create, get, update, delete) - User with matching UID can access/modify their horoscopes.
     * @deny (create, get, update, delete) - Any other user cannot access/modify another user's horoscopes.
     * @principle Enforces document ownership for user horoscopes.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      allow get, list: if isOwner(userId);

      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Secure deity content. Public read-only.
     * @path /deities/{deityId}
     * @allow (get, list) - Anyone can read deity data.
     * @deny (create, update, delete) - No one can create/modify deity data.
     * @principle Public read-only access.
     */
    match /deities/{deityId} {
      allow get, list: if true;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure shop content. Public read, owner-only writes.
     * @path /shops/{shopId}
     * @allow (get, list) - Anyone can read shop data.
     * @allow (create) - Only the authenticated user who is the owner of this shop can create the shop.
     * @allow (update, delete) - Only the authenticated user who is the owner of this shop can update/delete.
     * @deny (create, update, delete) - Any other user cannot create/modify another user's shop.
     * @principle Public read access with owner-only writes.
     */
    match /shops/{shopId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.ownerId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.ownerId == request.auth.uid && resource != null;
    }

    /**
     * @description Secure product content. Public read-only.
     * @path /products/{productId}
     * @allow (get, list) - Anyone can read product data.
     * @deny (create, update, delete) - No one can create/modify product data.
     * @principle Public read-only access.
     */
    match /products/{productId} {
      allow get, list: if true;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure temple data. Public read-only.
     * @path /temples/{templeId}
     * @allow (get, list) - Anyone can read temple data.
     * @deny (create, update, delete) - No one can create/modify temple data.
     * @principle Public read-only access.
     */
    match /temples/{templeId} {
      allow get, list: if true;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure reviews for temples.
     * @path /temples/{templeId}/reviews/{reviewId}
     */
    match /temples/{templeId}/reviews/{reviewId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
    }

    /**
     * @description Secure posts for temples.
     * @path /temples/{templeId}/posts/{postId}
     */
    match /temples/{templeId}/posts/{postId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

    /**
     * @description Secure story content. Public read-only.
     * @path /stories/{storyId}
     * @allow (get, list) - Anyone can read story data.
     * @deny (create, update, delete) - No one can create/modify story data.
     * @principle Public read-only access.
     */
    match /stories/{storyId} {
      allow get, list: if true;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure epic hero content. Public read-only.
     * @path /epicHeroes/{heroId}
     * @allow (get, list) - Anyone can read epic hero data.
     * @deny (create, update, delete) - No one can create/modify epic hero data.
     * @principle Public read-only access.
     */
    match /epicHeroes/{heroId} {
      allow get, list: if true;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure ritual content. Public read-only.
     * @path /rituals/{ritualId}
     * @allow (get, list) - Anyone can read ritual data.
     * @deny (create, update, delete) - No one can create/modify ritual data.
     * @principle Public read-only access.
     */
    match /rituals/{ritualId} {
      allow get, list: if true;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure panchang data. Public read-only.
     * @path /panchang/{date}
     * @allow (get, list) - Anyone can read panchang data.
     * @deny (create, update, delete) - No one can create/modify panchang data.
     * @principle Public read-only access.
     */
    match /panchang/{date} {
      allow get, list: if true;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure festival data. Public read-only.
     * @path /festivals/{festivalId}
     * @allow (get, list) - Anyone can read festival data.
     * @deny (create, update, delete) - No one can create/modify festival data.
     * @principle Public read-only access.
     */
    match /festivals/{festivalId} {
      allow get, list: if true;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure community groups.
     * @path /groups/{groupId}
     */
    match /groups/{groupId} {
      allow get, list: if true; // Publicly readable

      allow create: if isSignedIn(); // Anyone can create a group
      allow update: if isSignedIn(); // Anyone can update group info
      allow delete: if false; // Nobody can delete
    }

    /**
     * @description Secure members of a group
     * @path /groups/{groupId}/members/{userId}
     */
    match /groups/{groupId}/members/{userId} {
        allow get, list: if true; //Publicly readable for member list

        allow create: if isSignedIn() && request.auth.uid == userId; // User can join the group
        allow update: if false;
        allow delete: if isSignedIn() && request.auth.uid == userId && resource != null; //User can leave the group
    }

    /**
     * @description Secure posts within a group.
     * @path /groups/{groupId}/posts/{postId}
     */
    match /groups/{groupId}/posts/{postId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

    /**
     * @description Secure comments for posts within a group.
     * @path /groups/{groupId}/posts/{postId}/comments/{commentId}
     */
    match /groups/{groupId}/posts/{postId}/comments/{commentId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

     /**
     * @description Secure likes for group posts.
     * @path /groups/{groupId}/posts/{postId}/likes/{userId}
     */
    match /groups/{groupId}/posts/{postId}/likes/{userId} {
      allow get, list: if true; // Publicly readable to show like count.

      allow create: if isSignedIn() && userId == request.auth.uid; // User can like
      allow update: if false; // Likes are idempotent
      allow delete: if isSignedIn() && userId == request.auth.uid && resource != null; //User can unlike
    }

    /**
     * @description Secure community challenges. Public read-only.
     * @path /challenges/{challengeId}
     */
    match /challenges/{challengeId} {
      allow get, list: if true;

      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure manifestation posts. Public read, owner-only writes.
     * @path /manifestations/{manifestationId}
     */
    match /manifestations/{manifestationId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;
    }

    /**
     * @description Secure comments on manifestation posts. Public read, owner-only writes.
     * @path /manifestations/{manifestationId}/comments/{commentId}
     */
    match /manifestations/{manifestationId}/comments/{commentId} {
      allow get, list: if true;

      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
    }

    /**
     * @description Secure likes for manifestation posts.
     * @path /manifestations/{manifestationId}/likes/{userId}
     */
    match /manifestations/{manifestationId}/likes/{userId} {
      allow get, list: if true; // Publicly readable to show like count.

      allow create: if isSignedIn() && userId == request.auth.uid; // User can like
      allow update: if false; // Likes are idempotent
      allow delete: if isSignedIn() && userId == request.auth.uid && resource != null; //User can unlike
    }
  }
}