/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for personal data while allowing public read access to shared content.
 *
 * Data Structure:
 * - User-specific data (profiles, preferences, bookmarks, virtual offerings, orders, playlists, challenges, horoscopes, cart) is nested under `/users/{userId}`.
 * - Social connections (followers, following) are managed via subcollections under `/users/{userId}`.
 * - Public content (media, channels, playlists, deities, shops, products, temples, stories, epic heroes, rituals, festivals, panchang, groups, manifestations, challenges) resides in top-level collections.
 * - Likes for media, group posts, and manifestations are stored in subcollections.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - All write operations on user-owned data require authentication and ownership validation.
 * - Public content is readable by all users but writable only with specific authorization (e.g., owner-only or role-based).
 *
 * Denormalization for Authorization:
 * - User-specific data includes the userId for easy authorization checks.
 * - Ownership fields (e.g., `userId`, `creatorId`, `ownerId`) are used to control write access to public content.
 *
 * Structural Segregation:
 * - Private user data and public content are stored in separate collections to optimize security and querying.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the existing owner of the resource.
     */
    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }

    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) Authenticated user creates their profile.
     * @allow (get, update, delete) Authenticated user accesses/modifies their own profile.
     * @deny (create) Unauthenticated user attempts to create a profile.
     * @deny (get, update, delete) Authenticated user attempts to access/modify another user's profile.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id; //Enforce immutability
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Rules for followers subcollection.
      * @path /users/{userId}/followers/{followerId}
      * @allow (create) Any signed-in user can create a follow document.
      * @allow (get, list) The owner can read their followers.
      * @deny (update, delete) Only the system can update or delete follow records.
      * @principle Data in this collection is user-specific but readable by the owning user.
      */
    match /users/{userId}/followers/{followerId} {
        allow get, list: if isOwner(userId);
        allow create: if isSignedIn();
        allow update, delete: if false;
    }

    /**
     * @description Rules for following subcollection.
     * @path /users/{userId}/following/{followedId}
     * @allow (create) Any signed-in user can create a following document.
     * @allow (get, list) The owner can read who they are following.
     * @deny (update, delete) Only the system can update or delete following records.
     * @principle Data in this collection is user-specific but readable by the owning user.
     */
    match /users/{userId}/following/{followedId} {
        allow get, list: if isOwner(userId);
        allow create: if isSignedIn();
        allow update, delete: if false;
    }

    /**
     * @description Rules for user preferences.
     * @path /users/{userId}/preferences/default
     * @allow (get, update) Authenticated user accesses/modifies their own preferences.
     * @allow (create) Authenticated user creates their preferences.
     * @deny (delete) Prevent client-side deletion.
     * @deny (get, update) Authenticated user attempts to access/modify another user's preferences.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/preferences/default {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if false;
    }

     /**
      * @description Rules for user badges.
      * @path /users/{userId}/badges/{badgeId}
      * @allow (get, list) The owner can read their badges.
      * @deny (create, update, delete) Only the system can manage badges.
      * @principle Data in this collection is user-specific but readable by the owning user.
      */
    match /users/{userId}/badges/{badgeId} {
        allow get, list: if isOwner(userId);
        allow create, update, delete: if false;
    }

    /**
     * @description Rules for user bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (get, create, delete, list) Authenticated user manages their own bookmarks.
     * @deny (get, create, delete, list) Authenticated user attempts to access/modify another user's bookmarks.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/bookmarks/{bookmarkId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for virtual offerings.
     * @path /users/{userId}/virtualOfferings/{offeringId}
     * @allow (get, create, list) Authenticated user manages their own virtual offerings.
     * @deny (get, create, list) Authenticated user attempts to access/modify another user's virtual offerings.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/virtualOfferings/{offeringId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false;
      allow delete: if false; //No deleting virtual offerings.
    }

    /**
     * @description Rules for cart items.
     * @path /users/{userId}/cart/{productId}
     * @allow (get, create, update, delete, list) Authenticated user manages their own cart.
     * @deny (get, create, update, delete, list) Authenticated user attempts to access/modify another user's cart.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/cart/{productId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow (get, list) Authenticated user can view their own orders.
     * @deny (create, update, delete) Prevent client-side creation, updates, and deletions.
     * @principle Enforces document ownership for reads.
     */
    match /users/{userId}/orders/{orderId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create, update, delete: if false;
    }

    /**
     * @description Rules for user playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (get, create, list) Authenticated user manages their own playlist references.
     * @deny (get, create, list) Authenticated user attempts to access/modify another user's playlists.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/playlists/{playlistId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if false;
        allow delete: if false; //Playlists themselves are in a top-level collection
    }

    /**
     * @description Rules for user challenge progress.
     * @path /users/{userId}/challenges/{challengeId}
     * @allow (get, create, update, list) Authenticated user manages their own challenge progress.
     * @deny (get, create, update, list) Authenticated user attempts to access/modify another user's challenge progress.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/challenges/{challengeId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if false; //No deleting challenge progress.
    }

    /**
     * @description Rules for media.
     * @path /media/{mediaId}
     * @allow (get, list) Public read access for all media.
     * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no ownerId is present on the Media entity.
     * @principle Public read, restricted writes (MISSING OWNER FIELD).
     */
    match /media/{mediaId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for comments on media.
     * @path /media/{mediaId}/comments/{commentId}
     * @allow (get, list) Public read access for comments.
     * @allow (create) Authenticated users can create comments.
     * @deny (update, delete) Only the owner can modify/delete.
     * @principle Public read, owner-only writes.
     */
    match /media/{mediaId}/comments/{commentId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if isExistingOwner(request.auth.uid);
        allow delete: if isExistingOwner(request.auth.uid);
    }

   /**
    * @description Rules for likes on media.
    * @path /media/{mediaId}/likes/{userId}
    * @allow (get, list) Public read access for all likes.
    * @allow (create, delete) Authenticated user can like/unlike.
    * @deny (update) No updates.
    * @principle Public read, authenticated like/unlike.
    */
    match /media/{mediaId}/likes/{userId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Rules for channels.
     * @path /channels/{channelId}
     * @allow (get, list) Public read access for all channels.
     * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no ownerId is present on the Channel entity.
     * @principle Public read, restricted writes (MISSING OWNER FIELD).
     */
    match /channels/{channelId} {
      allow get, list: if true;
       allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for playlists.
     * @path /playlists/{playlistId}
     * @allow (get, list) Public read access for all playlists.
     * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no creatorId is present on the Playlist entity.
     * @principle Public read, restricted writes (MISSING OWNER FIELD).
     */
    match /playlists/{playlistId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for horoscopes.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (get, list) Authenticated user can access their own horoscopes.
     * @deny (create, update, delete) Horoscopes are system-generated.
     * @principle Owner-only read, system-only writes.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create, update, delete: if false;
    }

    /**
     * @description Rules for deities.
     * @path /deities/{deityId}
     * @allow (get, list) Public read access for all deities.
     * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no ownerId is present on the Deity entity.
     * @principle Public read, restricted writes (MISSING OWNER FIELD).
     */
    match /deities/{deityId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for shops.
     * @path /shops/{shopId}
     * @allow (get, list) Public read access for all shops.
     * @allow (create) Authenticated user can create a shop if they own the shop.
     * @deny (update, delete) Only the owner can modify/delete.
     * @principle Public read, owner-only writes.
     */
    match /shops/{shopId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && request.resource.data.ownerId == resource.data.ownerId;
      allow delete: if isSignedIn() && request.resource.data.ownerId == resource.data.ownerId;
    }

    /**
     * @description Rules for products.
     * @path /products/{productId}
     * @allow (get, list) Public read access for all products.
     * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no shopId is present on the Product entity to link back to the shop.
     * @principle Public read, restricted writes (MISSING OWNER FIELD).
     */
    match /products/{productId} {
      allow get, list: if true;
       allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for temples.
     * @path /temples/{templeId}
     * @allow (get, list) Public read access for all temples.
     * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no ownerId is present on the Temple entity.
     * @principle Public read, restricted writes (MISSING OWNER FIELD).
     */
    match /temples/{templeId} {
      allow get, list: if true;
       allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for reviews on temples.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (get, list) Public read access for all reviews.
     * @allow (create) Authenticated users can create reviews.
     * @deny (update, delete) Only the owner can modify/delete.
     * @principle Public read, owner-only writes.
     */
    match /temples/{templeId}/reviews/{reviewId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(request.auth.uid);
      allow delete: if isExistingOwner(request.auth.uid);
    }

    /**
     * @description Rules for posts on temples.
     * @path /temples/{templeId}/posts/{postId}
     * @allow (get, list) Public read access for all posts.
     * @allow (create) Authenticated users can create posts.
     * @deny (update, delete) Only the owner can modify/delete.
     * @principle Public read, owner-only writes.
     */
    match /temples/{templeId}/posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(request.auth.uid);
      allow delete: if isExistingOwner(request.auth.uid);
    }

     /**
      * @description Rules for stories.
      * @path /stories/{storyId}
      * @allow (get, list) Public read access for all stories.
      * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no ownerId is present on the Story entity.
      * @principle Public read, restricted writes (MISSING OWNER FIELD).
      */
    match /stories/{storyId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for epic heroes.
     * @path /epicHeroes/{heroId}
     * @allow (get, list) Public read access for all heroes.
     * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no ownerId is present on the EpicHero entity.
     * @principle Public read, restricted writes (MISSING OWNER FIELD).
     */
    match /epicHeroes/{heroId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for rituals.
     * @path /rituals/{ritualId}
     * @allow (get, list) Public read access for all rituals.
     * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no ownerId is present on the Ritual entity.
     * @principle Public read, restricted writes (MISSING OWNER FIELD).
     */
    match /rituals/{ritualId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for Panchang data.
     * @path /panchang/{date}
     * @allow (get, list) Public read access for all panchang data.
     * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no ownerId is present on the Panchang entity.
     * @principle Public read, restricted writes (MISSING OWNER FIELD).
     */
    match /panchang/{date} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for festivals.
     * @path /festivals/{festivalId}
     * @allow (get, list) Public read access for all festivals.
     * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no ownerId is present on the Festival entity.
     * @principle Public read, restricted writes (MISSING OWNER FIELD).
     */
    match /festivals/{festivalId} {
      allow get, list: if true;
       allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for community groups.
     * @path /groups/{groupId}
     * @allow (get, list) Public read access for all groups.
     * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no ownerId is present on the Group entity.
     * @principle Public read, restricted writes (MISSING OWNER FIELD).
     */
    match /groups/{groupId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Rules for group members.
     * @path /groups/{groupId}/members/{userId}
     * @allow get, list: if true;
     * @allow create: if isSignedIn();
     * @deny update, delete: if false;
     * @principle Public read, restricted writes.
     */
    match /groups/{groupId}/members/{userId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if false; //Let the backend handle deletes
    }

    /**
     * @description Rules for posts in a group.
     * @path /groups/{groupId}/posts/{postId}
     * @allow (get, list) Public read access for all group posts.
     * @allow (create) Authenticated users can create group posts.
     * @deny (update, delete) Only the owner can modify/delete.
     * @principle Public read, owner-only writes.
     */
    match /groups/{groupId}/posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(request.auth.uid);
      allow delete: if isExistingOwner(request.auth.uid);
    }

   /**
    * @description Rules for likes on group posts.
    * @path /groups/{groupId}/posts/{postId}/likes/{userId}
    * @allow (get, list) Public read access for all likes.
    * @allow (create, delete) Authenticated user can like/unlike.
    * @deny (update) No updates.
    * @principle Public read, authenticated like/unlike.
    */
    match /groups/{groupId}/posts/{postId}/likes/{userId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if isSignedIn() && request.auth.uid == userId;
    }

   /**
    * @description Rules for comments on group posts.
    * @path /groups/{groupId}/posts/{postId}/comments/{commentId}
    * @allow (get, list) Public read access for all comments.
    * @allow (create) Authenticated users can create comments.
    * @deny (update, delete) Only the owner can modify/delete.
    * @principle Public read, owner-only writes.
    */
    match /groups/{groupId}/posts/{postId}/comments/{commentId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if isExistingOwner(request.auth.uid);
        allow delete: if isExistingOwner(request.auth.uid);
    }

   /**
    * @description Rules for community challenges.
    * @path /challenges/{challengeId}
    * @allow (get, list) Public read access for all challenges.
    * @deny (create, update, delete) Owner-only writes are NOT POSSIBLE because no ownerId is present on the Challenge entity.
    * @principle Public read, restricted writes (MISSING OWNER FIELD).
    */
     match /challenges/{challengeId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

   /**
    * @description Rules for manifestation posts.
    * @path /manifestations/{manifestationId}
    * @allow (get, list) Public read access for all posts.
    * @allow (create) Authenticated users can create posts.
    * @deny (update, delete) Only the owner can modify/delete.
    * @principle Public read, owner-only writes.
    */
    match /manifestations/{manifestationId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(request.auth.uid) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(request.auth.uid) && resource.data.userId == request.auth.uid;
    }

   /**
    * @description Rules for likes on manifestation posts.
    * @path /manifestations/{manifestationId}/likes/{userId}
    * @allow (get, list) Public read access for all likes.
    * @allow (create, delete) Authenticated user can like/unlike.
    * @deny (update) No updates.
    * @principle Public read, authenticated like/unlike.
    */
    match /manifestations/{manifestationId}/likes/{userId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if isSignedIn() && request.auth.uid == userId;
    }

   /**
    * @description Rules for comments on manifestation posts.
    * @path /manifestations/{manifestationId}/comments/{commentId}
    * @allow (get, list) Public read access for all comments.
    * @allow (create) Authenticated users can create comments.
    * @deny (update, delete) Only the owner can modify/delete.
    * @principle Public read, owner-only writes.
    */
    match /manifestations/{manifestationId}/comments/{commentId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if isExistingOwner(request.auth.uid);
        allow delete: if isExistingOwner(request.auth.uid);
    }
  }
}