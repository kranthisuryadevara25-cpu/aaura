rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profiles.
     * @path /users/{userId}
     * @allow (create) - Authenticated user can create their own profile (userId matches auth.uid).
     * @allow (get, list, update, delete) - Authenticated user can only access their own profile.
     * @deny (create) - If the user ID does not match the authenticated user's ID.
     * @deny (update, delete) - If the user ID does not match the authenticated user's ID or the document does not exist.
     * @principle Enforces user-ownership for profile data.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
          return isOwner(userId) && resource.data.keys().hasAll(['userId']) && resource.data.userId == request.auth.uid;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to user preferences.
     * @path /users/{userId}/preferences/default
     * @allow (create) - Authenticated user can create their own preferences (userId matches auth.uid).
     * @allow (get, list, update, delete) - Authenticated user can only access their own preferences.
     * @deny (create) - If the user ID does not match the authenticated user's ID.
     * @deny (update, delete) - If the user ID does not match the authenticated user's ID or the document does not exist.
     * @principle Enforces user-ownership for preference data.
     */
    match /users/{userId}/preferences/default {
        function isSignedIn() {
            return request.auth != null;
        }
        function isOwner(userId) {
            return request.auth.uid == userId;
        }
        function isExistingOwner(userId) {
            return isOwner(userId) && resource.data.keys().hasAll(['userId']) && resource.data.userId == request.auth.uid;
        }

        allow get: if isSignedIn() && isOwner(userId);
        allow list: if false;
        allow create: if isSignedIn() && isOwner(userId);
        allow update: if isSignedIn() && isExistingOwner(userId);
        allow delete: if isSignedIn() && isExistingOwner(userId);
    }

      /**
       * @description Controls access to user bookmarks.
       * @path /users/{userId}/bookmarks/{bookmarkId}
       * @allow (create) - Authenticated user can create their own bookmark (userId matches auth.uid).
       * @allow (get, list, update, delete) - Authenticated user can only access their own bookmarks.
       * @deny (create) - If the user ID does not match the authenticated user's ID.
       * @deny (update, delete) - If the user ID does not match the authenticated user's ID or the document does not exist.
       * @principle Enforces user-ownership for bookmark data.
       */
    match /users/{userId}/bookmarks/{bookmarkId} {
        function isSignedIn() {
            return request.auth != null;
        }
        function isOwner(userId) {
            return request.auth.uid == userId;
        }
        function isExistingOwner(userId) {
            return isOwner(userId) && resource.data.keys().hasAll(['userId']) && resource.data.userId == request.auth.uid;
        }

        allow get: if isSignedIn() && isOwner(userId);
        allow list: if isSignedIn() && isOwner(userId);
        allow create: if isSignedIn() && isOwner(userId);
        allow update: if isSignedIn() && isExistingOwner(userId);
        allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to media content.
     * @path /media/{mediaId}
     * @allow (get, list) - All users can read media.
     * @allow (create) - Any authenticated user can create media, but the media document MUST contain a "userId" that matches the authenticated user.
     * @allow (update, delete) - Only the owner of the media (identified by the userId field) can update or delete it, and only if the media document exists.
     * @deny (create) - If the 'userId' in the request does not match the authenticated user's ID.
     * @deny (update, delete) - If the document does not exist or if the authenticated user is not the owner of the media.
     * @principle Public read access with owner-only writes.
     */
    match /media/{mediaId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isExistingOwner(ownerId) {
          return isSignedIn() && isOwner(ownerId) && resource.data.keys().hasAll(['userId']) && resource.data.userId == request.auth.uid;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.keys().hasAll(['userId']) && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Controls access to channels.
     * @path /channels/{channelId}
     * @allow (get, list) - All users can read channel information.
     * @allow (create) - Any authenticated user can create a channel, but the channel document MUST contain a "userId" that matches the authenticated user.
     * @allow (update, delete) - Only the owner of the channel (identified by the userId field) can update or delete it, and only if the channel document exists.
     * @deny (create) - If the 'userId' in the request does not match the authenticated user's ID.
     * @deny (update, delete) - If the document does not exist or if the authenticated user is not the owner of the channel.
     * @principle Public read access with owner-only writes.
     */
    match /channels/{channelId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(ownerId) {
        return request.auth.uid == ownerId;
      }
      function isExistingOwner(ownerId) {
          return isSignedIn() && isOwner(ownerId) && resource.data.keys().hasAll(['userId']) && resource.data.userId == request.auth.uid;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.keys().hasAll(['userId']) && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Controls access to user subscriptions to channels.
     * @path /users/{userId}/subscriptions/{channelId}
     * @allow (create) - Authenticated user can create their own subscription (userId matches auth.uid).
     * @allow (get, list, update, delete) - Authenticated user can only access their own subscriptions.
     * @deny (create) - If the user ID does not match the authenticated user's ID.
     * @deny (update, delete) - If the user ID does not match the authenticated user's ID or the document does not exist.
     * @principle Enforces user-ownership for subscription data.
     */
     match /users/{userId}/subscriptions/{channelId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
          return isSignedIn() && isOwner(userId) && resource.data.keys().hasAll(['userId']) && resource.data.userId == request.auth.uid;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to horoscopes generated for users.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (create) - Authenticated user can create their own horoscope (userId matches auth.uid).
     * @allow (get, list, update, delete) - Authenticated user can only access their own horoscopes.
     * @deny (create) - If the user ID does not match the authenticated user's ID.
     * @deny (update, delete) - If the user ID does not match the authenticated user's ID or the document does not exist.
     * @principle Enforces user-ownership for horoscope data.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(userId) {
        return request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
          return isSignedIn() && isOwner(userId) && resource.data.keys().hasAll(['userId']) && resource.data.userId == request.auth.uid;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Controls access to deities.
     * @path /deities/{deityId}
     * @allow (get, list) - All users can read deity information.
     * @allow (create, update, delete) - No one can create, update or delete deities.
     * @principle Public read access, no write access.
     */
    match /deities/{deityId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to shops.
     * @path /shops/{shopId}
     * @allow (get, list) - All users can read shop information.
     * @allow (create) - Any authenticated user can create a shop, but the shop document MUST contain a "ownerId" that matches the authenticated user.
     * @allow (update, delete) - Only the owner of the shop (identified by the ownerId field) can update or delete it, and only if the shop document exists.
     * @deny (create) - If the 'ownerId' in the request does not match the authenticated user's ID.
     * @deny (update, delete) - If the document does not exist or if the authenticated user is not the owner of the shop.
     * @principle Public read access with owner-only writes.
     */
    match /shops/{shopId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(ownerId) {
        return request.auth.uid == ownerId;
      }
      function isExistingOwner(ownerId) {
          return isSignedIn() && isOwner(ownerId) && resource.data.keys().hasAll(['ownerId']) && resource.data.ownerId == request.auth.uid;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.keys().hasAll(['ownerId']) && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Controls access to products.
     * @path /products/{productId}
     * @allow (get, list) - All users can read product information.
     * @allow (create) - Anyone can create, but this should be protected by server side logic
     * @allow (update, delete) - No one can update or delete products.
     * @principle Public read access, but create/update/delete are open (requires server-side protection).
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to temples.
     * @path /temples/{templeId}
     * @allow (get, list) - All users can read temple information.
     * @allow (create, update, delete) - No one can create, update or delete temples.
     * @principle Public read access, no write access.
     */
    match /temples/{templeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to temple reviews.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (get, list) - All users can read temple reviews.
     * @allow (create) - Any authenticated user can create a review. The review document MUST contain a "userId" that matches the authenticated user.
     * @allow (update, delete) - Only the owner of the review can update or delete it.
     * @deny (create) - If the 'userId' in the request does not match the authenticated user's ID.
     * @deny (update, delete) - If the document does not exist or if the authenticated user is not the owner of the review.
     * @principle Public read access with owner-only writes.
     */
    match /temples/{templeId}/reviews/{reviewId} {
      function isSignedIn() {
        return request.auth != null;
      }
      function isOwner(ownerId) {
        return request.auth.uid == ownerId;
      }
      function isExistingOwner(ownerId) {
          return isSignedIn() && isOwner(ownerId) && resource.data.keys().hasAll(['userId']) && resource.data.userId == request.auth.uid;
      }
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.keys().hasAll(['userId']) && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Controls access to stories.
     * @path /stories/{storyId}
     * @allow (get, list) - All users can read story information.
     * @allow (create, update, delete) - No one can create, update or delete stories.
     * @principle Public read access, no write access.
     */
    match /stories/{storyId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to characters.
     * @path /characters/{characterId}
     * @allow (get, list) - All users can read character information.
     * @allow (create, update, delete) - No one can create, update or delete characters.
     * @principle Public read access, no write access.
     */
    match /characters/{characterId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to rituals.
     * @path /rituals/{ritualId}
     * @allow (get, list) - All users can read ritual information.
     * @allow (create, update, delete) - No one can create, update or delete rituals.
     * @principle Public read access, no write access.
     */
    match /rituals/{ritualId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to panchang data.
     * @path /panchang/{date}
     * @allow (get, list) - All users can read panchang data.
     * @allow (create, update, delete) - No one can create, update or delete panchang data.
     * @principle Public read access, no write access.
     */
    match /panchang/{date} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to festivals.
     * @path /festivals/{festivalId}
     * @allow (get, list) - All users can read festival information.
     * @allow (create, update, delete) - No one can create, update or delete festivals.
     * @principle Public read access, no write access.
     */
    match /festivals/{festivalId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

      /**
       * @description Controls access to forum posts.
       * @path /posts/{postId}
       * @allow (get, list) - All users can read forum posts.
       * @allow (create) - Any authenticated user can create a post, but the post document MUST contain a "authorId" that matches the authenticated user.
       * @allow (update, delete) - Only the owner of the post can update or delete it.
       * @deny (create) - If the 'authorId' in the request does not match the authenticated user's ID.
       * @deny (update, delete) - If the document does not exist or if the authenticated user is not the owner of the post.
       * @principle Public read access with owner-only writes.
       */
    match /posts/{postId} {
        function isSignedIn() {
            return request.auth != null;
        }
        function isOwner(ownerId) {
            return request.auth.uid == ownerId;
        }
        function isExistingOwner(ownerId) {
            return isSignedIn() && isOwner(ownerId) && resource.data.keys().hasAll(['authorId']) && resource.data.authorId == request.auth.uid;
        }
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.keys().hasAll(['authorId']) && request.resource.data.authorId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.authorId);
        allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Controls access to comments on forum posts.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (get, list) - All users can read comments on forum posts.
     * @allow (create) - Any authenticated user can create a comment. The comment document MUST contain a "authorId" that matches the authenticated user.
     * @allow (update, delete) - Only the owner of the comment can update or delete it.
     * @deny (create) - If the 'authorId' in the request does not match the authenticated user's ID.
     * @deny (update, delete) - If the document does not exist or if the authenticated user is not the owner of the comment.
     * @principle Public read access with owner-only writes.
     */
    match /posts/{postId}/comments/{commentId} {
        function isSignedIn() {
            return request.auth != null;
        }
        function isOwner(ownerId) {
            return request.auth.uid == ownerId;
        }
        function isExistingOwner(ownerId) {
            return isSignedIn() && isOwner(ownerId) && resource.data.keys().hasAll(['authorId']) && resource.data.authorId == request.auth.uid;
        }
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.resource.data.keys().hasAll(['authorId']) && request.resource.data.authorId == request.auth.uid;
        allow update: if isExistingOwner(resource.data.authorId);
        allow delete: if isExistingOwner(resource.data.authorId);
    }
  }
}