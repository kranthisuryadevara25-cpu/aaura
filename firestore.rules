/**
 * @fileoverview Firestore Security Rules for the aaura app.
 *
 * Core Philosophy:
 * This ruleset prioritizes user data ownership and restricts access to private user data.
 * It provides flexible access to public content while ensuring that only authorized users can modify data.
 *
 * Data Structure:
 * - User-specific data is nested under `/users/{userId}`.
 * - Public content (media, deities, temples, stories, etc.) resides in top-level collections.
 * - Follow relationships are managed through nested subcollections under each user.
 *
 * Key Security Decisions:
 * - Users can only read and write their own data under `/users/{userId}`.
 * - Listing of users is disallowed to prevent data scraping.
 * - Public content collections are generally readable by anyone.
 * - Write access to public content is restricted to authorized users (typically content creators/owners).
 * - Follow relationships are managed through nested subcollections under each user, allowing users to manage their own follower and following lists.
 *
 * Denormalization for Authorization:
 *  None (the schema already uses ownerId fields where necessary).
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user is the owner of the resource.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

     /**
      * @description Checks if the authenticated user is the existing owner of the resource.
      */
     function isExistingOwner(userId) {
       return isOwner(userId) && resource != null;
     }

    /**
     * @description Rules for user profiles.
     * @path /users/{userId}
     * @allow (create) User with ID 'user123' can create their profile.
     *   - request.auth.uid: 'user123'
     *   - request.resource.data.id: 'user123'
     * @allow (get) User with ID 'user123' can read their profile.
     *   - request.auth.uid: 'user123'
     * @allow (update) User with ID 'user123' can update their profile.
     *   - request.auth.uid: 'user123'
     * @allow (delete) User with ID 'user123' can delete their profile.
     *   - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot create a profile for 'user123'.
     *   - request.auth.uid: 'user456'
     *   - request.resource.data.id: 'user123'
     * @deny (update) User with ID 'user456' cannot update the profile of 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (delete) User with ID 'user456' cannot delete the profile of 'user123'.
     *   - request.auth.uid: 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user's contest progress.
     * @path /users/{userId}/contestProgress/{contestId}
     * @allow (create) User with ID 'user123' can create their contest progress.
     *   - request.auth.uid: 'user123'
     * @allow (get) User with ID 'user123' can read their contest progress.
     *   - request.auth.uid: 'user123'
     * @allow (update) User with ID 'user123' can update their contest progress.
     *   - request.auth.uid: 'user123'
     * @allow (delete) User with ID 'user123' can delete their contest progress.
     *   - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot create contest progress for 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (update) User with ID 'user456' cannot update the contest progress of 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (delete) User with ID 'user456' cannot delete the contest progress of 'user123'.
     *   - request.auth.uid: 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/contestProgress/{contestId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user's followers.
     * @path /users/{userId}/followers/{followerId}
     * @allow (create) User with ID 'follower123' can create a follow relationship to 'user123'.
     *   - request.auth.uid: 'follower123'
     * @allow (get) User with ID 'user123' can read a follower.
     *   - request.auth.uid: 'user123'
     * @allow (delete) User with ID 'follower123' can delete their follow relationship to 'user123'.
     *   - request.auth.uid: 'follower123'
     * @deny (create) User with ID 'user456' cannot create a follow relationship for 'follower123' to 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (update) Updates are not permitted on follow relationships.
     *   - request.auth.uid: 'user123'
     * @principle Allows users to manage their own follower list.
     */
    match /users/{userId}/followers/{followerId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isSignedIn() && request.auth.uid == followerId;
      allow update: if false;
      allow delete: if isSignedIn() && request.auth.uid == followerId;
    }

    /**
     * @description Rules for users following others.
     * @path /users/{userId}/following/{followedId}
     * @allow (create) User with ID 'user123' can create a following relationship to 'followed456'.
     *   - request.auth.uid: 'user123'
     * @allow (get) User with ID 'user123' can read who they are following.
     *   - request.auth.uid: 'user123'
     * @allow (delete) User with ID 'user123' can delete their following relationship to 'followed456'.
     *   - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot create a following relationship for 'user123' to 'followed456'.
     *   - request.auth.uid: 'user456'
     * @deny (update) Updates are not permitted on following relationships.
     *   - request.auth.uid: 'user123'
     * @principle Allows users to manage their own following list.
     */
    match /users/{userId}/following/{followedId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.auth.uid == userId;
      allow update: if false;
      allow delete: if isOwner(userId) && request.auth.uid == userId;
    }

    /**
     * @description Rules for user preferences.
     * @path /users/{userId}/preferences/default
     * @allow (create) User with ID 'user123' can create their preferences.
     *   - request.auth.uid: 'user123'
     * @allow (get) User with ID 'user123' can read their preferences.
     *   - request.auth.uid: 'user123'
     * @allow (update) User with ID 'user123' can update their preferences.
     *   - request.auth.uid: 'user123'
     * @allow (delete) User with ID 'user123' can delete their preferences.
     *   - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot create preferences for 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (update) User with ID 'user456' cannot update the preferences of 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (delete) User with ID 'user456' cannot delete the preferences of 'user123'.
     *   - request.auth.uid: 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/preferences/default {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user's badges.
     * @path /users/{userId}/badges/{badgeId}
     * @allow (create) User with ID 'user123' can create their badge (likely by backend).
     *   - request.auth.uid: 'user123'
     * @allow (get) User with ID 'user123' can read their badge.
     *   - request.auth.uid: 'user123'
     * @allow (update) User with ID 'user123' can update their badge (likely by backend).
     *   - request.auth.uid: 'user123'
     * @allow (delete) User with ID 'user123' can delete their badge (likely by backend).
     *   - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot create a badge for 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (update) User with ID 'user456' cannot update the badge of 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (delete) User with ID 'user456' cannot delete the badge of 'user123'.
     *   - request.auth.uid: 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/badges/{badgeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for user's bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (create) User with ID 'user123' can create their bookmark.
     *   - request.auth.uid: 'user123'
     * @allow (get) User with ID 'user123' can read their bookmark.
     *   - request.auth.uid: 'user123'
     * @allow (update) User with ID 'user123' can update their bookmark.
     *   - request.auth.uid: 'user123'
     * @allow (delete) User with ID 'user123' can delete their bookmark.
     *   - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot create a bookmark for 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (update) User with ID 'user456' cannot update the bookmark of 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (delete) User with ID 'user456' cannot delete the bookmark of 'user123'.
     *   - request.auth.uid: 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/bookmarks/{bookmarkId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Rules for user's virtual offerings.
      * @path /users/{userId}/virtualOfferings/{offeringId}
      * @allow (create) User with ID 'user123' can create their offering.
      *   - request.auth.uid: 'user123'
      * @allow (get) User with ID 'user123' can read their offering.
      *   - request.auth.uid: 'user123'
      * @allow (update) User with ID 'user123' can update their offering.
      *   - request.auth.uid: 'user123'
      * @allow (delete) User with ID 'user123' can delete their offering.
      *   - request.auth.uid: 'user123'
      * @deny (create) User with ID 'user456' cannot create a offering for 'user123'.
      *   - request.auth.uid: 'user456'
      * @deny (update) User with ID 'user456' cannot update the offering of 'user123'.
      *   - request.auth.uid: 'user456'
      * @deny (delete) User with ID 'user456' cannot delete the offering of 'user123'.
      *   - request.auth.uid: 'user456'
      * @principle Enforces document ownership for writes.
      */
    match /users/{userId}/virtualOfferings/{offeringId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Rules for user's cart items.
      * @path /users/{userId}/cart/{productId}
      * @allow (create) User with ID 'user123' can create cart item.
      *   - request.auth.uid: 'user123'
      * @allow (get) User with ID 'user123' can read cart item.
      *   - request.auth.uid: 'user123'
      * @allow (update) User with ID 'user123' can update cart item.
      *   - request.auth.uid: 'user123'
      * @allow (delete) User with ID 'user123' can delete cart item.
      *   - request.auth.uid: 'user123'
      * @deny (create) User with ID 'user456' cannot create cart item for 'user123'.
      *   - request.auth.uid: 'user456'
      * @deny (update) User with ID 'user456' cannot update the cart item of 'user123'.
      *   - request.auth.uid: 'user456'
      * @deny (delete) User with ID 'user456' cannot delete the cart item of 'user123'.
      *   - request.auth.uid: 'user456'
      * @principle Enforces document ownership for writes.
      */
    match /users/{userId}/cart/{productId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Rules for orders.
      * @path /orders/{orderId}
      * @allow (create) Only allow create if user is signed in.
      *   - request.auth.uid: 'user123'
      * @allow (get) Only allow get if user is signed in.
      *   - request.auth.uid: 'user123'
      * @allow (update) Only allow update if user is signed in.
      *   - request.auth.uid: 'user123'
      * @allow (delete) Only allow delete if user is signed in.
      *   - request.auth.uid: 'user123'
      * @deny (create) User is not signed in.
      *   - request.auth.uid: null
      * @principle Requires authentication for access.
      */
    match /orders/{orderId} {
      allow get: if isSignedIn();
      allow list: if false;
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Rules for playlists created by users (references).
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create) User with ID 'user123' can create a playlist reference.
     *   - request.auth.uid: 'user123'
     * @allow (get) User with ID 'user123' can read their playlist references.
     *   - request.auth.uid: 'user123'
     * @allow (update) User with ID 'user123' can update their playlist reference.
     *   - request.auth.uid: 'user123'
     * @allow (delete) User with ID 'user123' can delete their playlist reference.
     *   - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot create a playlist reference for 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (update) User with ID 'user456' cannot update the playlist reference of 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (delete) User with ID 'user456' cannot delete the playlist reference of 'user123'.
     *   - request.auth.uid: 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/playlists/{playlistId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Rules for user's challenges.
      * @path /users/{userId}/challenges/{challengeId}
      * @allow (create) User with ID 'user123' can create user challenge.
      *   - request.auth.uid: 'user123'
      * @allow (get) User with ID 'user123' can read user challenge.
      *   - request.auth.uid: 'user123'
      * @allow (update) User with ID 'user123' can update user challenge.
      *   - request.auth.uid: 'user123'
      * @allow (delete) User with ID 'user123' can delete user challenge.
      *   - request.auth.uid: 'user123'
      * @deny (create) User with ID 'user456' cannot create user challenge for 'user123'.
      *   - request.auth.uid: 'user456'
      * @deny (update) User with ID 'user456' cannot update the user challenge of 'user123'.
      *   - request.auth.uid: 'user456'
      * @deny (delete) User with ID 'user456' cannot delete the user challenge of 'user123'.
      *   - request.auth.uid: 'user456'
      * @principle Enforces document ownership for writes.
      */
    match /users/{userId}/challenges/{challengeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for media content.
     * @path /media/{mediaId}
     * @allow (get) Anyone can read media content.
     * @allow (list) Anyone can list media content.
     * @allow (create) Only allow create if user is signed in.
     *   - request.auth.uid: 'user123'
     *   - request.resource.data.userId: 'user123'
     * @allow (update) Only allow update if user is signed in.
     *   - request.auth.uid: 'user123'
     *   - resource.data.userId: 'user123'
     * @allow (delete) Only allow delete if user is signed in.
     *   - request.auth.uid: 'user123'
     *   - resource.data.userId: 'user123'
     * @deny (create) User is not signed in.
     *   - request.auth.uid: null
     * @deny (update) User is not signed in.
     *   - request.auth.uid: null
     * @deny (delete) User is not signed in.
     *   - request.auth.uid: null
     * @principle Allows public read access with authenticated writes.
     */
    match /media/{mediaId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

    /**
     * @description Rules for media comments.
     * @path /media/{mediaId}/comments/{commentId}
     * @allow (create) Only allow create if user is signed in.
     *   - request.auth.uid: 'user123'
     * @allow (get) Anyone can read media comments.
     * @allow (list) Anyone can list media comments.
     * @allow (update) Only allow update if user is signed in.
     *   - request.auth.uid: 'user123'
     *   - resource.data.authorId: 'user123'
     * @allow (delete) Only allow delete if user is signed in.
     *   - request.auth.uid: 'user123'
     *   - resource.data.authorId: 'user123'
     * @deny (create) User is not signed in.
     *   - request.auth.uid: null
     * @deny (update) User is not signed in.
     *   - request.auth.uid: null
     * @deny (delete) User is not signed in.
     *   - request.auth.uid: null
     * @principle Allows public read access with authenticated writes.
     */
    match /media/{mediaId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

      /**
       * @description Rules for likes on media items.
       * @path /media/{mediaId}/likes/{userId}
       * @allow (create) User with ID 'user123' can like the media item.
       *   - request.auth.uid: 'user123'
       * @allow (get) Anyone can read the like.
       * @allow (delete) User with ID 'user123' can unlike the media item.
       *   - request.auth.uid: 'user123'
       * @deny (create) User with ID 'user456' cannot create a like for 'user123'.
       *   - request.auth.uid: 'user456'
       * @deny (update) Updates are not permitted on likes.
       *   - request.auth.uid: 'user123'
       * @principle Allows authenticated users to like and unlike media.
       */
      match /media/{mediaId}/likes/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if false;
        allow delete: if isSignedIn() && request.auth.uid == userId;
      }

    /**
     * @description Rules for channels.
     * @path /channels/{channelId}
     * @allow (get) Anyone can read channel information.
     * @allow (list) Anyone can list channel information.
     * @allow (create) Only allow create if user is signed in.
     *   - request.auth.uid: 'user123'
     *   - request.resource.data.userId: 'user123'
     * @allow (update) Only allow update if user is signed in and is the owner.
     *   - request.auth.uid: 'user123'
     *   - resource.data.userId: 'user123'
     * @allow (delete) Only allow delete if user is signed in and is the owner.
     *   - request.auth.uid: 'user123'
     *   - resource.data.userId: 'user123'
     * @deny (create) User is not signed in.
     *   - request.auth.uid: null
     * @deny (update) User is not signed in or not owner.
     *   - request.auth.uid: null
     * @deny (delete) User is not signed in or not owner.
     *   - request.auth.uid: null
     * @principle Allows public read access with authenticated writes by the owner.
     */
    match /channels/{channelId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

    /**
     * @description Rules for playlists.
     * @path /playlists/{playlistId}
     * @allow (get) Anyone can read playlist information.
     * @allow (list) Anyone can list playlists.
     * @allow (create) Only allow create if user is signed in.
     *   - request.auth.uid: 'user123'
     *   - request.resource.data.creatorId: 'user123'
     * @allow (update) Only allow update if user is signed in and is the owner.
     *   - request.auth.uid: 'user123'
     *   - resource.data.creatorId: 'user123'
     * @allow (delete) Only allow delete if user is signed in and is the owner.
     *   - request.auth.uid: 'user123'
     *   - resource.data.creatorId: 'user123'
     * @deny (create) User is not signed in.
     *   - request.auth.uid: null
     * @deny (update) User is not signed in or not owner.
     *   - request.auth.uid: null
     * @deny (delete) User is not signed in or not owner.
     *   - request.auth.uid: null
     * @principle Allows public read access with authenticated writes by the owner.
     */
    match /playlists/{playlistId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.creatorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.creatorId);
    }

    /**
     * @description Rules for horoscopes.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (get) User with ID 'user123' can read their horoscope.
     *   - request.auth.uid: 'user123'
     * @allow (list) User with ID 'user123' can list their horoscopes.
     *   - request.auth.uid: 'user123'
     * @allow (create) User with ID 'user123' can create their horoscope (likely by backend).
     *   - request.auth.uid: 'user123'
     * @allow (update) User with ID 'user123' can update their horoscope (likely by backend).
     *   - request.auth.uid: 'user123'
     * @allow (delete) User with ID 'user123' can delete their horoscope (likely by backend).
     *   - request.auth.uid: 'user123'
     * @deny (create) User with ID 'user456' cannot create a horoscope for 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (update) User with ID 'user456' cannot update the horoscope of 'user123'.
     *   - request.auth.uid: 'user456'
     * @deny (delete) User with ID 'user456' cannot delete the horoscope of 'user123'.
     *   - request.auth.uid: 'user456'
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Rules for deities.
     * @path /deities/{deityId}
     * @allow (get) Anyone can read deity information.
     * @allow (list) Anyone can list deities.
     * @allow create: if false; // TODO: Add admin role check
     * allow update: if false; // TODO: Add admin role check
     * allow delete: if false; // TODO: Add admin role check
     * @principle Public read access, restricted writes.
     */
    match /deities/{deityId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add admin role check
      allow update: if false; // TODO: Add admin role check
      allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rules for shops.
     * @path /shops/{shopId}
     * @allow (get) Anyone can read shop information.
     * @allow (list) Anyone can list shops.
     * @allow (create) Only the shop owner can create.
     *   - request.auth.uid: 'user123'
     *   - request.resource.data.ownerId: 'user123'
     * @allow (update) Only the shop owner can update.
     *   - request.auth.uid: 'user123'
     *   - resource.data.ownerId: 'user123'
     * @allow (delete) Only the shop owner can delete.
     *   - request.auth.uid: 'user123'
     *   - resource.data.ownerId: 'user123'
     * @principle Shop owner has full access to their shops.
     */
    match /shops/{shopId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.ownerId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Rules for products.
     * @path /products/{productId}
     * @allow (get) Anyone can read product information.
     * @allow (list) Anyone can list products.
     * allow create: if false; // TODO: Add admin role check
     * allow update: if false; // TODO: Add admin role check
     * allow delete: if false; // TODO: Add admin role check
     * @principle Public read access, restricted writes.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
       allow create: if false; // TODO: Add admin role check
       allow update: if false; // TODO: Add admin role check
       allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rules for temples.
     * @path /temples/{templeId}
     * @allow (get) Anyone can read temple information.
     * @allow (list) Anyone can list temples.
     * allow create: if false; // TODO: Add admin role check
     * allow update: if false; // TODO: Add admin role check
     * allow delete: if false; // TODO: Add admin role check
     * @principle Public read access, restricted writes.
     */
    match /temples/{templeId} {
      allow get: if true;
      allow list: if true;
       allow create: if false; // TODO: Add admin role check
       allow update: if false; // TODO: Add admin role check
       allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rules for temple reviews.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (create) Only allow create if user is signed in.
     *   - request.auth.uid: 'user123'
     *   - request.resource.data.userId: 'user123'
     * @allow (get) Anyone can read temple review.
     * @allow (list) Anyone can list temple review.
     * @allow (update) Only the review author can update.
     *   - request.auth.uid: 'user123'
     *   - resource.data.userId: 'user123'
     * @allow (delete) Only the review author can delete.
     *   - request.auth.uid: 'user123'
     *   - resource.data.userId: 'user123'
     * @deny (create) User is not signed in.
     *   - request.auth.uid: null
     * @deny (update) User is not signed in or not owner.
     *   - request.auth.uid: null
     * @deny (delete) User is not signed in or not owner.
     *   - request.auth.uid: null
     * @principle Allows public read with authenticated writes by the owner.
     */
    match /temples/{templeId}/reviews/{reviewId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

      /**
       * @description Rules for temple posts.
       * @path /temples/{templeId}/posts/{postId}
       * @allow (create) Only allow create if user is signed in.
       *   - request.auth.uid: 'user123'
       *   - request.resource.data.authorId: 'user123'
       * @allow (get) Anyone can read temple post.
       * @allow (list) Anyone can list temple posts.
       * @allow (update) Only the post author can update.
       *   - request.auth.uid: 'user123'
       *   - resource.data.authorId: 'user123'
       * @allow (delete) Only the post author can delete.
       *   - request.auth.uid: 'user123'
       *   - resource.data.authorId: 'user123'
       * @deny (create) User is not signed in.
       *   - request.auth.uid: null
       * @deny (update) User is not signed in or not owner.
       *   - request.auth.uid: null
       * @deny (delete) User is not signed in or not owner.
       *   - request.auth.uid: null
       * @principle Allows public read with authenticated writes by the owner.
       */
    match /temples/{templeId}/posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

     /**
      * @description Rules for stories.
      * @path /stories/{storyId}
      * @allow (get) Anyone can read story information.
      * @allow (list) Anyone can list stories.
      * allow create: if false; // TODO: Add admin role check
      * allow update: if false; // TODO: Add admin role check
      * allow delete: if false; // TODO: Add admin role check
      * @principle Public read access, restricted writes.
      */
    match /stories/{storyId} {
      allow get: if true;
      allow list: if true;
       allow create: if false; // TODO: Add admin role check
       allow update: if false; // TODO: Add admin role check
       allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rules for epic heroes.
     * @path /epicHeroes/{heroId}
     * @allow (get) Anyone can read epic hero information.
     * @allow (list) Anyone can list epic heroes.
     * allow create: if false; // TODO: Add admin role check
     * allow update: if false; // TODO: Add admin role check
     * allow delete: if false; // TODO: Add admin role check
     * @principle Public read access, restricted writes.
     */
    match /epicHeroes/{heroId} {
      allow get: if true;
      allow list: if true;
       allow create: if false; // TODO: Add admin role check
       allow update: if false; // TODO: Add admin role check
       allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rules for rituals.
     * @path /rituals/{ritualId}
     * @allow (get) Anyone can read ritual information.
     * @allow (list) Anyone can list rituals.
     * allow create: if false; // TODO: Add admin role check
     * allow update: if false; // TODO: Add admin role check
     * allow delete: if false; // TODO: Add admin role check
     * @principle Public read access, restricted writes.
     */
    match /rituals/{ritualId} {
      allow get: if true;
      allow list: if true;
       allow create: if false; // TODO: Add admin role check
       allow update: if false; // TODO: Add admin role check
       allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rules for panchang data.
     * @path /panchang/{date}
     * @allow (get) Anyone can read panchang data.
     * @allow (list) Anyone can list panchang data.
     * allow create: if false; // TODO: Add admin role check
     * allow update: if false; // TODO: Add admin role check
     * allow delete: if false; // TODO: Add admin role check
     * @principle Public read access, restricted writes.
     */
    match /panchang/{date} {
      allow get: if true;
      allow list: if true;
       allow create: if false; // TODO: Add admin role check
       allow update: if false; // TODO: Add admin role check
       allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rules for festivals.
     * @path /festivals/{festivalId}
     * @allow (get) Anyone can read festival information.
     * @allow (list) Anyone can list festivals.
     * allow create: if false; // TODO: Add admin role check
     * allow update: if false; // TODO: Add admin role check
     * allow delete: if false; // TODO: Add admin role check
     * @principle Public read access, restricted writes.
     */
    match /festivals/{festivalId} {
      allow get: if true;
      allow list: if true;
       allow create: if false; // TODO: Add admin role check
       allow update: if false; // TODO: Add admin role check
       allow delete: if false; // TODO: Add admin role check
    }

     /**
      * @description Rules for community groups.
      * @path /groups/{groupId}
      * @allow (get) Anyone can read group information.
      * @allow (list) Anyone can list groups.
      * allow create: if false; // TODO: Add admin role check
      * allow update: if false; // TODO: Add admin role check
      * allow delete: if false; // TODO: Add admin role check
      * @principle Public read access, restricted writes.
      */
    match /groups/{groupId} {
      allow get: if true;
      allow list: if true;
       allow create: if false; // TODO: Add admin role check
       allow update: if false; // TODO: Add admin role check
       allow delete: if false; // TODO: Add admin role check
    }

       /**
        * @description Rules for group members.
        * @path /groups/{groupId}/members/{userId}
        * @allow (create) Only allow create if user is signed in.
        * @allow (get) Anyone can read group members.
        * @allow (list) Anyone can list group members.
        * @allow (update) Updates are not permitted.
        * @allow (delete) Only allow delete if user is signed in.
        * @principle Allows users to join groups.
        */
    match /groups/{groupId}/members/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if isSignedIn();
    }

       /**
        * @description Rules for posts within a specific group.
        * @path /posts/{postId}
        * @allow (create) Only allow create if user is signed in.
        *   - request.auth.uid: 'user123'
        *   - request.resource.data.authorId: 'user123'
        * @allow (get) Anyone can read post.
        * @allow (list) Anyone can list posts.
        * @allow (update) Only the post author can update.
        *   - request.auth.uid: 'user123'
        *   - resource.data.authorId: 'user123'
        * @allow (delete) Only the post author can delete.
        *   - request.auth.uid: 'user123'
        *   - resource.data.authorId: 'user123'
        * @deny (create) User is not signed in.
        *   - request.auth.uid: null
        * @deny (update) User is not signed in or not owner.
        *   - request.auth.uid: null
        * @deny (delete) User is not signed in or not owner.
        *   - request.auth.uid: null
        * @principle Allows public read with authenticated writes by the owner.
        */
    match /posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

      /**
       * @description Rules for comments on posts within a group.
       * @path /posts/{postId}/comments/{commentId}
       * @allow (create) Only allow create if user is signed in.
       * @allow (get) Anyone can read post comments.
       * @allow (list) Anyone can list post comments.
       * @allow (update) Only the comment author can update.
       * @allow (delete) Only the comment author can delete.
       * @principle Allows public read access with authenticated writes by the owner.
       */
    match /posts/{postId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

      /**
       * @description Rules for likes on a forum post within a group.
       * @path /posts/{postId}/likes/{userId}
       * @allow (create) User with ID 'user123' can like the forum post.
       * @allow (get) Anyone can read the like.
       * @allow (delete) User with ID 'user123' can unlike the forum post.
       * @deny (create) User with ID 'user456' cannot create a like for 'user123'.
       * @deny (update) Updates are not permitted on likes.
       * @principle Allows authenticated users to like and unlike forum posts.
       */
    match /posts/{postId}/likes/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if false;
      allow delete: if isSignedIn() && request.auth.uid == userId;
    }

     /**
      * @description Rules for community challenges.
      * @path /challenges/{challengeId}
      * @allow (get) Anyone can read challenge information.
      * @allow (list) Anyone can list challenges.
      * allow create: if false; // TODO: Add admin role check
      * allow update: if false; // TODO: Add admin role check
      * allow delete: if false; // TODO: Add admin role check
      * @principle Public read access, restricted writes.
      */
    match /challenges/{challengeId} {
      allow get: if true;
      allow list: if true;
       allow create: if false; // TODO: Add admin role check
       allow update: if false; // TODO: Add admin role check
       allow delete: if false; // TODO: Add admin role check
    }

     /**
      * @description Rules for global chanting contests.
      * @path /contests/{contestId}
      * @allow (get) Anyone can read contest information.
      * @allow (list) Anyone can list contests.
      * allow create: if false; // TODO: Add admin role check
      * allow update: if false; // TODO: Add admin role check
      * allow delete: if false; // TODO: Add admin role check
      * @principle Public read access, restricted writes.
      */
    match /contests/{contestId} {
      allow get: if true;
      allow list: if true;
       allow create: if false; // TODO: Add admin role check
       allow update: if false; // TODO: Add admin role check
       allow delete: if false; // TODO: Add admin role check
    }

    /**
     * @description Rules for user-submitted manifestation techniques and stories.
     * @path /manifestations/{manifestationId}
     * @allow (create) Only allow create if user is signed in.
     *   - request.auth.uid: 'user123'
     *   - request.resource.data.userId: 'user123'
     * @allow (get) Anyone can read manifestation post.
     * @allow (list) Anyone can list manifestation posts.
     * @allow (update) Only the post author can update.
     *   - request.auth.uid: 'user123'
     *   - resource.data.userId: 'user123'
     * @allow (delete) Only the post author can delete.
     *   - request.auth.uid: 'user123'
     *   - resource.data.userId: 'user123'
     * @deny (create) User is not signed in.
     *   - request.auth.uid: null
     * @deny (update) User is not signed in or not owner.
     *   - request.auth.uid: null
     * @deny (delete) User is not signed in or not owner.
     *   - request.auth.uid: null
     * @principle Allows public read with authenticated writes by the owner.
     */
    match /manifestations/{manifestationId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.userId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.userId);
    }

    /**
     * @description Rules for comments on manifestation posts.
     * @path /manifestations/{manifestationId}/comments/{commentId}
     * @allow (create) Only allow create if user is signed in.
     * @allow (get) Anyone can read manifestation post comments.
     * @allow (list) Anyone can list manifestation post comments.
     * @allow (update) Only the comment author can update.
     * @allow (delete) Only the comment author can delete.
     * @principle Allows public read access with authenticated writes by the owner.
     */
    match /manifestations/{manifestationId}/comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Rules for likes on a manifestation post.
     * @path /manifestations/{manifestationId}/likes/{userId}
     * @allow (create) User with ID 'user123' can like the manifestation post.
     * @allow (get) Anyone can read the like.
     * @allow (delete) User with ID 'user123' can unlike the manifestation post.
     * @deny (create) User with ID 'user456' cannot create a like for 'user123'.
     * @deny (update) Updates are not permitted on likes.
     * @principle Allows authenticated users to like and unlike manifestation posts.
     */
    match /manifestations/{manifestationId}/likes/{userId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == userId;
      allow update: if false;
      allow delete: if isSignedIn() && request.auth.uid == userId;
    }
  }
}