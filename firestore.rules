/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a strict user-ownership model for personal data while allowing public read access to shared content.
 *
 * Data Structure:
 * - User-specific data (profiles, preferences, bookmarks, cart, orders, playlists, horoscopes) is nested under `/users/{userId}`.
 * - Public content (media, channels, playlists, deities, shops, products, temples, stories, rituals, festivals, challenges, contests, manifestations, posts) resides in top-level collections.
 * - Social connections (followers, following) are managed with nested subcollections under `/users/{userId}`.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profiles and associated data.
 * - Public content is readable by all, but writable only by authorized admins (requires `auth.token.admin == true`).
 * - User listing is implicitly denied because there is no rule allowing it on the `/users` collection.
 * - Follower/Following relationships are managed via explicit `create` and `delete` operations to ensure data consistency and prevent unauthorized modifications.
 *
 * Denormalization for Authorization:
 * - The rules rely on the `request.auth.uid` to match the `userId` in the path for user-specific data, avoiding costly `get()` operations.
 * - Admin access is controlled through the `auth.token.admin` claim, which must be set externally (e.g., via a Firebase Function).
 *
 * Structural Segregation:
 * - Public content and private user data are stored in separate collections to simplify read/write rules and improve performance for public listing operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by the authenticated user.
     * @return {bool} True if the user is signed in; false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user's ID matches the provided userId.
     * @param {string} userId The user ID to compare against.
     * @return {bool} True if the user is the owner; false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is an existing owner.
     * @param {string} userId The user ID to compare against.
     * @return {bool} True if the user is the owner and the resource exists; false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Checks if the authenticated user has admin privileges.
     * @return {bool} True if the user is an admin; false otherwise.
     */
    function isAdmin() {
      return isSignedIn() && request.auth.token.admin == true;
    }

    /**
     * @description Defines rules for user profiles.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' creates their profile: `request.auth.uid == 'user123'`
     * @allow (read) User with UID 'user123' reads their own profile: `request.auth.uid == 'user123'`
     * @allow (update) User with UID 'user123' updates their own profile: `request.auth.uid == 'user123'`
     * @allow (delete) User with UID 'user123' deletes their own profile: `request.auth.uid == 'user123'`
     * @deny (create) User with UID 'user123' tries to create profile for 'user456': `request.auth.uid != 'user456'`
     * @deny (read) User with UID 'user123' tries to read profile for 'user456': `request.auth.uid != 'user456'`
     * @deny (update) User with UID 'user123' tries to update profile for 'user456': `request.auth.uid != 'user456'`
     * @deny (delete) User with UID 'user123' tries to delete profile for 'user456': `request.auth.uid != 'user456'`
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // User listing is explicitly forbidden.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);

       /**
         * @description Defines rules for tracking users who are following a specific user.
         * @path /users/{userId}/followers/{followerId}
         * @allow (create) User with UID 'follower123' follows user 'user123': `request.auth.uid == 'follower123'`
         * @allow (read) User with UID 'user123' reads who is following them (`followerId`): `request.auth.uid == 'user123'`
         * @allow (delete) User with UID 'follower123' unfollows user 'user123': `request.auth.uid == 'follower123'`
         * @deny (create) User with UID 'otherUser' attempts to follow user 'user123' using UID 'follower123': `request.auth.uid != 'follower123'`
         * @deny (read) User with UID 'otherUser' attempts to read followers of user 'user123': `request.auth.uid != 'user123'`
         * @principle Enforces self-follow relationships and prevents unauthorized access to follower lists.
         */
      match /followers/{followerId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isSignedIn() && request.auth.uid == followerId;
        allow update: if false; // Follow relationships shouldn't be updated.
        allow delete: if isSignedIn() && request.auth.uid == followerId && resource != null;
      }

      /**
       * @description Defines rules for tracking users a specific user is following.
       * @path /users/{userId}/following/{followedId}
       * @allow (create) User with UID 'user123' follows user 'followed456': `request.auth.uid == 'user123'`
       * @allow (read) User with UID 'user123' reads who they are following (`followedId`): `request.auth.uid == 'user123'`
       * @allow (delete) User with UID 'user123' unfollows user 'followed456': `request.auth.uid == 'user123'`
       * @deny (create) User with UID 'otherUser' attempts to make user 'user123' follow user 'followed456': `request.auth.uid != 'user123'`
       * @deny (read) User with UID 'otherUser' attempts to read following list of user 'user123': `request.auth.uid != 'user123'`
       * @principle Enforces self-follow relationships and prevents unauthorized access to following lists.
       */
      match /following/{followedId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if false; // Following relationships shouldn't be updated.
        allow delete: if isOwner(userId) && resource != null;
      }

       /**
        * @description Defines rules for user's cart items.
        * @path /users/{userId}/cart/{productId}
        * @allow (create) User with UID 'user123' adds item to cart: `request.auth.uid == 'user123'`
        * @allow (read) User with UID 'user123' reads their cart: `request.auth.uid == 'user123'`
        * @allow (update) User with UID 'user123' updates their cart: `request.auth.uid == 'user123'`
        * @allow (delete) User with UID 'user123' deletes item from cart: `request.auth.uid == 'user123'`
        * @deny (create) User with UID 'otherUser' attempts to add item to cart for user 'user123': `request.auth.uid != 'user123'`
        * @deny (read) User with UID 'otherUser' attempts to read cart of user 'user123': `request.auth.uid != 'user123'`
        * @principle Enforces user-ownership of cart data.
        */
      match /cart/{productId} {
          allow get: if isOwner(userId);
          allow list: if isOwner(userId);
          allow create: if isOwner(userId);
          allow update: if isExistingOwner(userId);
          allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Defines rules for user preferences.
       * @path /users/{userId}/preferences/default
       * @allow (create) User with UID 'user123' creates their preferences: `request.auth.uid == 'user123'`
       * @allow (read) User with UID 'user123' reads their preferences: `request.auth.uid == 'user123'`
       * @allow (update) User with UID 'user123' updates their preferences: `request.auth.uid == 'user123'`
       * @allow (delete) Denied, preferences should not be deleted.
       * @deny (create) User with UID 'otherUser' attempts to create preferences for user 'user123': `request.auth.uid != 'user123'`
       * @deny (read) User with UID 'otherUser' attempts to read preferences of user 'user123': `request.auth.uid != 'user123'`
       * @principle Enforces user-ownership of preference data.
       */
      match /preferences/default {
        allow get: if isOwner(userId);
        allow list: if false;
        allow create: if isOwner(userId);
        allow update: if isOwner(userId) && resource != null;
        allow delete: if false;
      }

      /**
       * @description Defines rules for user badges.
       * @path /users/{userId}/badges/{badgeId}
       * @allow (create) User with UID 'user123' is awarded a badge: `request.auth.uid == 'user123'` (Typically, this is managed by backend logic, not direct client writes)
       * @allow (read) User with UID 'user123' reads their badges: `request.auth.uid == 'user123'`
       * @allow (update) Denied, badges should not be updated.
       * @allow (delete) Denied, badges should not be deleted.
       * @deny (create) User with UID 'otherUser' attempts to create badges for user 'user123': `request.auth.uid != 'user123'`
       * @deny (read) User with UID 'otherUser' attempts to read badges of user 'user123': `request.auth.uid != 'user123'`
       * @principle Enforces user-ownership of badge data.
       */
      match /badges/{badgeId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId); // Backend function to award badges
        allow update: if false;
        allow delete: if false;
      }

      /**
       * @description Defines rules for user bookmarks.
       * @path /users/{userId}/bookmarks/{bookmarkId}
       * @allow (create) User with UID 'user123' creates a bookmark: `request.auth.uid == 'user123'`
       * @allow (read) User with UID 'user123' reads their bookmarks: `request.auth.uid == 'user123'`
       * @allow (update) Denied, bookmarks should not be updated.
       * @allow (delete) User with UID 'user123' deletes a bookmark: `request.auth.uid == 'user123'`
       * @deny (create) User with UID 'otherUser' attempts to create a bookmark for user 'user123': `request.auth.uid != 'user123'`
       * @deny (read) User with UID 'otherUser' attempts to read bookmarks of user 'user123': `request.auth.uid != 'user123'`
       * @principle Enforces user-ownership of bookmark data.
       */
      match /bookmarks/{bookmarkId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if false;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Defines rules for user virtual offerings.
       * @path /users/{userId}/virtualOfferings/{offeringId}
       * @allow (create) User with UID 'user123' creates a virtual offering: `request.auth.uid == 'user123'`
       * @allow (read) User with UID 'user123' reads their virtual offerings: `request.auth.uid == 'user123'`
       * @allow (update) Denied, virtual offerings should not be updated.
       * @allow (delete) Denied, virtual offerings should not be deleted.
       * @deny (create) User with UID 'otherUser' attempts to create a virtual offering for user 'user123': `request.auth.uid != 'user123'`
       * @deny (read) User with UID 'otherUser' attempts to read virtual offerings of user 'user123': `request.auth.uid != 'user123'`
       * @principle Enforces user-ownership of virtual offering data.
       */
      match /virtualOfferings/{offeringId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if false;
        allow delete: if false;
      }

      /**
       * @description Defines rules for user orders.
       * @path /users/{userId}/orders/{orderId}
       * @allow (create) User with UID 'user123' creates an order: `request.auth.uid == 'user123'`
       * @allow (read) User with UID 'user123' reads their orders: `request.auth.uid == 'user123'`
       * @allow (update) Denied, orders should not be updated (status updates managed by backend).
       * @allow (delete) Denied, orders should not be deleted.
       * @deny (create) User with UID 'otherUser' attempts to create an order for user 'user123': `request.auth.uid != 'user123'`
       * @deny (read) User with UID 'otherUser' attempts to read orders of user 'user123': `request.auth.uid != 'user123'`
       * @principle Enforces user-ownership of order data.
       */
      match /orders/{orderId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if false; // Status updates from backend
        allow delete: if false;
      }

      /**
       * @description Defines rules for user playlists (references to playlist documents).
       * @path /users/{userId}/playlists/{playlistId}
       * @allow (create) User with UID 'user123' creates a playlist reference: `request.auth.uid == 'user123'`
       * @allow (read) User with UID 'user123' reads their playlist references: `request.auth.uid == 'user123'`
       * @allow (update) Denied, playlist references should not be updated.
       * @allow (delete) User with UID 'user123' deletes a playlist reference: `request.auth.uid == 'user123'`
       * @deny (create) User with UID 'otherUser' attempts to create a playlist reference for user 'user123': `request.auth.uid != 'user123'`
       * @deny (read) User with UID 'otherUser' attempts to read playlist references of user 'user123': `request.auth.uid != 'user123'`
       * @principle Enforces user-ownership of playlist references.
       */
      match /playlists/{playlistId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if false;
        allow delete: if isExistingOwner(userId);
      }

      /**
       * @description Defines rules for user horoscopes.
       * @path /users/{userId}/horoscopes/{horoscopeId}
       * @allow (create) User with UID 'user123' has a horoscope generated for them: `request.auth.uid == 'user123'` (Horoscopes are likely generated by a backend service)
       * @allow (read) User with UID 'user123' reads their horoscope: `request.auth.uid == 'user123'`
       * @allow (update) Denied, horoscopes should not be updated.
       * @allow (delete) Denied, horoscopes should not be deleted.
       * @deny (create) User with UID 'otherUser' attempts to create a horoscope for user 'user123': `request.auth.uid != 'user123'`
       * @deny (read) User with UID 'otherUser' attempts to read horoscopes of user 'user123': `request.auth.uid != 'user123'`
       * @principle Enforces user-ownership of horoscope data.
       */
      match /horoscopes/{horoscopeId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId); // Managed by a backend function
        allow update: if false;
        allow delete: if false;
      }

        /**
         * @description Defines rules for tracking user's progress in community challenges.
         * @path /users/{userId}/challenges/{challengeId}
         * @allow (create) User with UID 'user123' starts challenge 'challenge123': `request.auth.uid == 'user123'`
         * @allow (read) User with UID 'user123' reads their challenge progress: `request.auth.uid == 'user123'`
         * @allow (update) User with UID 'user123' updates challenge progress: `request.auth.uid == 'user123'`
         * @allow (delete) Denied, challenge progress should not be deleted.
         * @deny (create) User with UID 'otherUser' attempts to create challenge progress for user 'user123': `request.auth.uid != 'user123'`
         * @deny (read) User with UID 'otherUser' attempts to read challenge progress of user 'user123': `request.auth.uid != 'user123'`
         * @principle Enforces user-ownership of challenge progress data.
         */
      match /challenges/{challengeId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if false;
      }

      /**
       * @description Defines rules for tracking user's contribution to a specific contest.
       * @path /users/{userId}/contestProgress/{contestId}
       * @allow (create) User with UID 'user123' contributes to contest 'contest123': `request.auth.uid == 'user123'`
       * @allow (read) User with UID 'user123' reads their contest progress: `request.auth.uid == 'user123'`
       * @allow (update) User with UID 'user123' updates their contest progress: `request.auth.uid == 'user123'`
       * @allow (delete) Denied, contest progress should not be deleted.
       * @deny (create) User with UID 'otherUser' attempts to create contest progress for user 'user123': `request.auth.uid != 'user123'`
       * @deny (read) User with UID 'otherUser' attempts to read contest progress of user 'user123': `request.auth.uid != 'user123'`
       * @principle Enforces user-ownership of contest progress data.
       */
      match /contestProgress/{contestId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if isExistingOwner(userId);
        allow delete: if false;
      }
    }

    /**
     * @description Defines rules for media content.
     * @path /media/{mediaId}
     * @allow (read) Anyone can read media content.
     * @allow (write) Only admins can create, update, or delete media content.
     * @principle Allows public read access with admin-only writes.
     */
    match /media/{mediaId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;

      /**
       * @description Defines rules for likes for a specific media item.
       * @path /media/{mediaId}/likes/{userId}
       * @allow (create) User with UID 'user123' likes media 'media123': `request.auth.uid == 'user123'`
       * @allow (read) Anyone can read likes on a media item.
       * @allow (delete) User with UID 'user123' unlikes media 'media123': `request.auth.uid == 'user123'`
       */
      match /likes/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if false;
        allow delete: if isSignedIn() && request.auth.uid == userId && resource != null;
      }

      /**
       * @description Defines rules for comments on media content.
       * @path /media/{mediaId}/comments/{commentId}
       * @allow (read) Anyone can read comments on media content.
       * @allow (create) Any signed-in user can create a comment.
       * @allow (update) Only admins can update comments.
       * @allow (delete) Only admins can delete comments.
       * @principle Allows public read access for comments with signed-in users creating and admins moderating.
       */
      match /comments/{commentId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn();
        allow update: if isAdmin() && resource != null;
        allow delete: if isAdmin() && resource != null;
      }
    }

    /**
     * @description Defines rules for channels.
     * @path /channels/{channelId}
     * @allow (read) Anyone can read channel information.
     * @allow (write) Only admins can create, update, or delete channels.
     * @principle Allows public read access with admin-only writes.
     */
    match /channels/{channelId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines rules for playlists.
     * @path /playlists/{playlistId}
     * @allow (read) Anyone can read playlists.
     * @allow (write) Only admins can create, update, or delete playlists.
     */
    match /playlists/{playlistId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines rules for deities.
     * @path /deities/{deityId}
     * @allow (read) Anyone can read deity information.
     * @allow (write) Only admins can create, update, or delete deity information.
     * @principle Allows public read access with admin-only writes.
     */
    match /deities/{deityId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines rules for shops.
     * @path /shops/{shopId}
     * @allow (read) Anyone can read shop information.
     * @allow (write) Only admins can create, update, or delete shops.
     * @principle Allows public read access with admin-only writes.
     */
    match /shops/{shopId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines rules for products.
     * @path /products/{productId}
     * @allow (read) Anyone can read product information.
     * @allow (write) Only admins can create, update, or delete products.
     * @principle Allows public read access with admin-only writes.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines rules for temples.
     * @path /temples/{templeId}
     * @allow (read) Anyone can read temple information.
     * @allow (write) Only admins can create, update, or delete temples.
     * @principle Allows public read access with admin-only writes.
     */
    match /temples/{templeId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;

      /**
       * @description Defines rules for reviews for a specific temple.
       * @path /temples/{templeId}/reviews/{reviewId}
       * @allow (read) Anyone can read reviews for a temple.
       * @allow (create) Any signed-in user can create a review.
       * @allow (update) Denied, reviews should not be updated.
       * @allow (delete) User with UID 'user123' deletes review of temple 'temple123': `request.auth.uid == 'user123' && resource.data.userId == request.auth.uid`
       * @principle Allows public read access for reviews with signed-in users creating and deleting their own reviews.
       */
      match /reviews/{reviewId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null; // Owner can delete
      }

      /**
       * @description Defines rules for posts for a specific temple.
       * @path /temples/{templeId}/posts/{postId}
       * @allow (read) Anyone can read posts for a temple.
       * @allow (create) Any signed-in user can create a post.
       * @allow (update) Denied, posts should not be updated.
       * @allow (delete) User with UID 'user123' deletes post of temple 'temple123': `request.auth.uid == 'user123' && resource.data.authorId == request.auth.uid`
       * @principle Allows public read access for posts with signed-in users creating and deleting their own posts.
       */
      match /posts/{postId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null; // Owner can delete
      }
    }

    /**
     * @description Defines rules for stories.
     * @path /stories/{storyId}
     * @allow (read) Anyone can read stories.
     * @allow (write) Only admins can create, update, or delete stories.
     * @principle Allows public read access with admin-only writes.
     */
    match /stories/{storyId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines rules for epic heroes.
     * @path /epicHeroes/{heroId}
     * @allow (read) Anyone can read epic hero information.
     * @allow (write) Only admins can create, update, or delete epic hero information.
     * @principle Allows public read access with admin-only writes.
     */
    match /epicHeroes/{heroId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines rules for rituals.
     * @path /rituals/{ritualId}
     * @allow (read) Anyone can read ritual information.
     * @allow (write) Only admins can create, update, or delete ritual information.
     * @principle Allows public read access with admin-only writes.
     */
    match /rituals/{ritualId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines rules for panchang data.
     * @path /panchang/{date}
     * @allow (read) Anyone can read panchang data.
     * @allow (write) Only admins can create, update, or delete panchang data.
     * @principle Allows public read access with admin-only writes.
     */
    match /panchang/{date} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines rules for festivals.
     * @path /festivals/{festivalId}
     * @allow (read) Anyone can read festival information.
     * @allow (write) Only admins can create, update, or delete festival information.
     * @principle Allows public read access with admin-only writes.
     */
    match /festivals/{festivalId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines rules for groups.
     * @path /groups/{groupId}
     * @allow (read) Anyone can read group information.
     * @allow (write) Only admins can create, update, or delete groups.
     */
    match /groups/{groupId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;

      /**
       * @description Defines rules for members of a group.
       * @path /groups/{groupId}/members/{userId}
       * @allow (create) Any signed-in user can join a group.
       * @allow (read) Anyone can read group members.
       * @allow (delete) Any signed-in user can leave a group.
       */
      match /members/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn();
        allow update: if false; // Membership shouldn't be updated.
        allow delete: if isSignedIn() && resource != null;
      }
    }

     /**
      * @description Defines rules for top-level posts in the community.
      * @path /posts/{postId}
      * @allow (read) Anyone can read posts.
      * @allow (create) Any signed-in user can create a post.
      * @allow (update) Denied, posts should not be updated.
      * @allow (delete) User with UID 'user123' deletes their post: `request.auth.uid == 'user123' && resource.data.authorId == request.auth.uid`
      * @principle Allows public read access for posts with signed-in users creating and deleting their own posts.
      */
    match /posts/{postId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;

      /**
        * @description Defines rules for likes for a specific post.
        * @path /posts/{postId}/likes/{userId}
        * @allow (create) User with UID 'user123' likes post 'post123': `request.auth.uid == 'user123'`
        * @allow (read) Anyone can read likes on a post.
        * @allow (delete) User with UID 'user123' unlikes post 'post123': `request.auth.uid == 'user123'`
        */
      match /likes/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if false;
        allow delete: if isSignedIn() && request.auth.uid == userId && resource != null;
      }

      /**
       * @description Defines rules for comments on community posts.
       * @path /posts/{postId}/comments/{commentId}
       * @allow (read) Anyone can read comments on posts.
       * @allow (create) Any signed-in user can create a comment.
       * @allow (update) Denied, comments should not be updated.
       * @allow (delete) User with UID 'user123' deletes their comment: `request.auth.uid == 'user123' && resource.data.authorId == request.auth.uid`
       * @principle Allows public read access for comments with signed-in users creating and deleting their own comments.
       */
      match /comments/{commentId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      }
    }

    /**
     * @description Defines rules for community challenges.
     * @path /challenges/{challengeId}
     * @allow (read) Anyone can read challenge information.
     * @allow (write) Only admins can create, update, or delete challenges.
     * @principle Allows public read access with admin-only writes.
     */
    match /challenges/{challengeId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

     /**
      * @description Defines rules for global chanting contests.
      * @path /contests/{contestId}
      * @allow (read) Anyone can read contest information.
      * @allow (write) Only admins can create, update, or delete contests.
      * @principle Allows public read access with admin-only writes.
      */
    match /contests/{contestId} {
      allow get: if true;
      allow list: if true;
      allow create: if isAdmin();
      allow update: if isAdmin() && resource != null;
      allow delete: if isAdmin() && resource != null;
    }

    /**
     * @description Defines rules for manifestation posts.
     * @path /manifestations/{manifestationId}
     * @allow (read) Anyone can read manifestation posts.
     * @allow (create) Any signed-in user can create a manifestation post.
     * @allow (update) Denied, manifestation posts should not be updated.
     * @allow (delete) User with UID 'user123' deletes their manifestation post: `request.auth.uid == 'user123' && resource.data.userId == request.auth.uid`
     * @principle Allows public read access for manifestation posts with signed-in users creating and deleting their own posts.
     */
    match /manifestations/{manifestationId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid && resource != null;

      /**
        * @description Defines rules for likes for a specific manifestation post.
        * @path /manifestations/{manifestationId}/likes/{userId}
        * @allow (create) User with UID 'user123' likes manifestation 'manifestation123': `request.auth.uid == 'user123'`
        * @allow (read) Anyone can read likes on a manifestation.
        * @allow (delete) User with UID 'user123' unlikes manifestation 'manifestation123': `request.auth.uid == 'user123'`
        */
      match /likes/{userId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if false;
        allow delete: if isSignedIn() && request.auth.uid == userId && resource != null;
      }

      /**
       * @description Defines rules for comments on manifestation posts.
       * @path /manifestations/{manifestationId}/comments/{commentId}
       * @allow (read) Anyone can read comments on manifestation posts.
       * @allow (create) Any signed-in user can create a comment.
       * @allow (update) Denied, comments should not be updated.
       * @allow (delete) User with UID 'user123' deletes their comment: `request.auth.uid == 'user123' && resource.data.authorId == request.auth.uid`
       * @principle Allows public read access for comments with signed-in users creating and deleting their own comments.
       */
      match /comments/{commentId} {
        allow get: if true;
        allow list: if true;
        allow create: if isSignedIn();
        allow update: if false;
        allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
      }
    }
  }
}