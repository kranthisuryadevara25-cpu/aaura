/**
 * @fileoverview Firestore Security Rules for the aaura app.
 *
 * Core Philosophy:
 * This ruleset employs a hybrid security model. User-specific data is protected by strict ownership rules, while public content collections are generally readable by all users. Write access to public collections is restricted to authorized users, usually the content creator, with ownership verified via the `authorId` field.
 *
 * Data Structure:
 * - `/users/{userId}`: Stores user profiles.
 * - `/users/{userId}/preferences/default`: Stores user preferences.
 * - `/users/{userId}/bookmarks/{bookmarkId}`: Stores user bookmarks for temples.
 * - `/media/{mediaId}`: Stores media items (videos, audio, etc.).
 * - `/channels/{channelId}`: Stores channel information.
 * - `/users/{userId}/subscriptions/{channelId}`: Stores user subscriptions to channels.
 * - `/users/{userId}/horoscopes/{horoscopeId}`: Stores user-specific horoscopes.
 * - `/deities/{deityId}`: Stores deity information.
 * - `/shops/{shopId}`: Stores shop information.
 * - `/products/{productId}`: Stores product information.
 * - `/temples/{templeId}`: Stores temple information.
 * - `/stories/{storyId}`: Stores mythological stories.
 * - `/characters/{characterId}`: Stores mythological characters.
 * - `/rituals/{ritualId}`: Stores ritual information.
 * - `/panchang/{date}`: Stores daily panchang data.
 * - `/festivals/{festivalId}`: Stores festival information.
 * - `/posts/{postId}`: Stores community forum posts.
 * - `/temples/{templeId}/reviews/{reviewId}`: Stores reviews for temples.
 * - `/media/{mediaId}/comments/{commentId}`: Stores comments for media items.
 * - `/posts/{postId}/comments/{commentId}`: Stores comments for posts.
 *
 * Key Security Decisions:
 * - User listing is disallowed.
 * - Data required for authorization (e.g., ownership) is denormalized onto documents to avoid costly `get()` calls in rules.
 * - Public read access is granted to several top-level collections, but writes are carefully controlled via ownership checks.
 *
 * Denormalization for Authorization:
 * The `Media`, `Shop`, and `Post` entities all have `userId` or `authorId` fields that are used to enforce ownership for write operations. This avoids costly lookups to other documents.
 *
 * Structural Segregation:
 * User-specific data (preferences, bookmarks, subscriptions, horoscopes) is stored in private subcollections under the `/users/{userId}` path, while public content (media, channels, deities, shops, products, temples, stories, characters, rituals, panchang, festivals, posts) is stored in top-level collections with public read access and owner-controlled write access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Secure user profiles. Users can only read/write their own profile data.
     * @path /users/{userId}
     * @allow (create) - User with ID 'user123' can create a profile if request.auth.uid == 'user123'.
     * @allow (get, update, delete) - User with ID 'user123' can get, update, or delete their own profile.
     * @deny (create) - User with ID 'user456' cannot create a profile with ID 'user123'.
     * @deny (get, update, delete) - User with ID 'user456' cannot get, update, or delete the profile with ID 'user123'.
     * @principle Enforces user-ownership.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && resource.data.id == userId;
      allow delete: if isOwner(userId) && resource.data.id == userId && resource != null;
    }

    /**
     * @description Secure user preferences. Users can only read/write their own preferences.
     * @path /users/{userId}/preferences/default
     * @allow (create) - User with ID 'user123' can create their preferences document.
     * @allow (get, update, delete) - User with ID 'user123' can get, update, or delete their own preferences.
     * @deny (create) - User with ID 'user456' cannot create preferences for 'user123'.
     * @deny (get, update, delete) - User with ID 'user456' cannot get, update, or delete preferences for 'user123'.
     * @principle Enforces user-ownership.
     */
    match /users/{userId}/preferences/default {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isOwner(userId) && resource != null;
    }

    /**
     * @description Secure user bookmarks. Users can only read/write their own bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (create) - User with ID 'user123' can create a bookmark.
     * @allow (get, update, delete) - User with ID 'user123' can get, update, or delete their own bookmarks.
     * @deny (create) - User with ID 'user456' cannot create a bookmark for 'user123'.
     * @deny (get, update, delete) - User with ID 'user456' cannot get, update, or delete a bookmark for 'user123'.
     * @principle Enforces user-ownership.
     */
    match /users/{userId}/bookmarks/{bookmarkId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isOwner(userId) && resource.data.userId == userId && resource != null;
    }

    /**
     * @description Secure media items. Public read, owner-only writes.
     * @path /media/{mediaId}
     * @allow (get, list) - Any user can read media items.
     * @allow (create) - User with ID 'user123' can create a media item with authorId: 'user123'.
     * @allow (update, delete) - User with ID 'user123' can update/delete the media if they are the author.
     * @deny (create) - User with ID 'user456' cannot create a media item with authorId: 'user123'.
     * @deny (update, delete) - User with ID 'user456' cannot update/delete media created by 'user123'.
     * @principle Public read, owner-only writes enforced.
     */
    match /media/{mediaId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

     /**
      * @description Secure comments for media items. Users can create comments, and only the author can delete or update them.
      * @path /media/{mediaId}/comments/{commentId}
      * @allow (get, list) - Any user can read comments for media items.
      * @allow (create) - Any signed-in user can create a comment on a media item.
      * @allow (update, delete) - Only the comment's author can update or delete it.
      * @deny (update, delete) - Another user cannot update or delete a comment they didn't create.
      * @principle Public read, owner-only updates/deletes.
      */
     match /media/{mediaId}/comments/{commentId} {
          function isOwner(userId) {
               return request.auth != null && request.auth.uid == userId;
          }

          function isExistingOwner(userId) {
               return isOwner(userId) && resource != null;
          }

          allow get: if true;
          allow list: if true;
          allow create: if isSignedIn();
          allow update: if isExistingOwner(resource.data.authorId);
          allow delete: if isExistingOwner(resource.data.authorId);
     }

    /**
     * @description Secure channels. Public read, owner-only writes.
     * @path /channels/{channelId}
     * @allow (get, list) - Any user can read channel information.
     * @allow (create) - User with ID 'user123' can create a channel with authorId: 'user123'.
     * @allow (update, delete) - User with ID 'user123' can update/delete the channel if they are the author.
     * @deny (create) - User with ID 'user456' cannot create a channel with authorId: 'user123'.
     * @deny (update, delete) - User with ID 'user456' cannot update/delete channel created by 'user123'.
     * @principle Public read, owner-only writes enforced.
     */
    match /channels/{channelId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      function isExistingOwner(userId) {
          return isOwner(userId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Secure user subscriptions. Users can only read/write their own subscriptions.
     * @path /users/{userId}/subscriptions/{channelId}
     * @allow (create) - User with ID 'user123' can create a subscription.
     * @allow (get, update, delete) - User with ID 'user123' can get, update, or delete their own subscriptions.
     * @deny (create) - User with ID 'user456' cannot create a subscription for 'user123'.
     * @deny (get, update, delete) - User with ID 'user456' cannot get, update, or delete a subscription for 'user123'.
     * @principle Enforces user-ownership.
     */
    match /users/{userId}/subscriptions/{channelId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isOwner(userId) && resource.data.userId == userId && resource != null;
    }

    /**
     * @description Secure user horoscopes. Users can only read/write their own horoscopes.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (create) - User with ID 'user123' can create a horoscope.
     * @allow (get, update, delete) - User with ID 'user123' can get, update, or delete their own horoscopes.
     * @deny (create) - User with ID 'user456' cannot create a horoscope for 'user123'.
     * @deny (get, update, delete) - User with ID 'user456' cannot get, update, or delete a horoscope for 'user123'.
     * @principle Enforces user-ownership.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isOwner(userId) && request.resource.data.userId == userId;
      allow delete: if isOwner(userId) && resource.data.userId == userId && resource != null;
    }

    /**
     * @description Secure deity information. Public read, no writes allowed.
     * @path /deities/{deityId}
     * @allow (get, list) - Any user can read deity information.
     * @deny (create, update, delete) - No user can create, update, or delete deity information.
     * @principle Public read, no writes.
     */
    match /deities/{deityId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure shop information. Public read, owner-only writes.
     * @path /shops/{shopId}
     * @allow (get, list) - Any user can read shop information.
     * @allow (create) - User with ID 'user123' can create a shop with ownerId: 'user123'.
     * @allow (update, delete) - User with ID 'user123' can update/delete the shop if they are the owner.
     * @deny (create) - User with ID 'user456' cannot create a shop with ownerId: 'user123'.
     * @deny (update, delete) - User with ID 'user456' cannot update/delete shop created by 'user123'.
     * @principle Public read, owner-only writes enforced.
     */
    match /shops/{shopId} {
      function isOwner(ownerId) {
        return request.auth != null && request.auth.uid == ownerId;
      }

      function isExistingOwner(ownerId) {
          return isOwner(ownerId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Secure product information. Public read, no writes allowed.
     * @path /products/{productId}
     * @allow (get, list) - Any user can read product information.
     * @deny (create, update, delete) - No user can create, update, or delete product information.
     * @principle Public read, no writes.
     */
    match /products/{productId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure temple information. Public read, no writes allowed.
     * @path /temples/{templeId}
     * @allow (get, list) - Any user can read temple information.
     * @deny (create, update, delete) - No user can create, update, or delete temple information.
     * @principle Public read, no writes.
     */
    match /temples/{templeId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure mythological stories. Public read, no writes allowed.
     * @path /stories/{storyId}
     * @allow (get, list) - Any user can read mythological stories.
     * @deny (create, update, delete) - No user can create, update, or delete mythological stories.
     * @principle Public read, no writes.
     */
    match /stories/{storyId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure mythological characters. Public read, no writes allowed.
     * @path /characters/{characterId}
     * @allow (get, list) - Any user can read mythological character information.
     * @deny (create, update, delete) - No user can create, update, or delete mythological character information.
     * @principle Public read, no writes.
     */
    match /characters/{characterId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure ritual information. Public read, no writes allowed.
     * @path /rituals/{ritualId}
     * @allow (get, list) - Any user can read ritual information.
     * @deny (create, update, delete) - No user can create, update, or delete ritual information.
     * @principle Public read, no writes.
     */
    match /rituals/{ritualId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure panchang data. Public read, no writes allowed.
     * @path /panchang/{date}
     * @allow (get, list) - Any user can read panchang data.
     * @deny (create, update, delete) - No user can create, update, or delete panchang data.
     * @principle Public read, no writes.
     */
    match /panchang/{date} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure festival information. Public read, no writes allowed.
     * @path /festivals/{festivalId}
     * @allow (get, list) - Any user can read festival information.
     * @deny (create, update, delete) - No user can create, update, or delete festival information.
     * @principle Public read, no writes.
     */
    match /festivals/{festivalId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Secure posts. Public read, owner-only writes.
     * @path /posts/{postId}
     * @allow (get, list) - Any user can read posts.
     * @allow (create) - User with ID 'user123' can create a post with authorId: 'user123'.
     * @allow (update, delete) - User with ID 'user123' can update/delete the post if they are the author.
     * @deny (create) - User with ID 'user456' cannot create a post with authorId: 'user123'.
     * @deny (update, delete) - User with ID 'user456' cannot update/delete post created by 'user123'.
     * @principle Public read, owner-only writes enforced.
     */
    match /posts/{postId} {
      function isOwner(authorId) {
        return request.auth != null && request.auth.uid == authorId;
      }

      function isExistingOwner(authorId) {
          return isOwner(authorId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

     /**
      * @description Secure comments for posts. Users can create comments, and only the author can delete or update them.
      * @path /posts/{postId}/comments/{commentId}
      * @allow (get, list) - Any user can read comments for posts.
      * @allow (create) - Any signed-in user can create a comment on a post.
      * @allow (update, delete) - Only the comment's author can update or delete it.
      * @deny (update, delete) - Another user cannot update or delete a comment they didn't create.
      * @principle Public read, owner-only updates/deletes.
      */
     match /posts/{postId}/comments/{commentId} {
          function isOwner(authorId) {
               return request.auth != null && request.auth.uid == authorId;
          }

          function isExistingOwner(authorId) {
               return isOwner(authorId) && resource != null;
          }

          allow get: if true;
          allow list: if true;
          allow create: if isSignedIn();
          allow update: if isExistingOwner(resource.data.authorId);
          allow delete: if isExistingOwner(resource.data.authorId);
     }

    /**
     * @description Secure reviews for temples. Users can create reviews, and only the author can delete or update them.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (get, list) - Any user can read reviews for temples.
     * @allow (create) - Any signed-in user can create a review for a temple.
     * @allow (update, delete) - Only the review's author can update or delete it.
     * @deny (update, delete) - Another user cannot update or delete a review they didn't create.
     * @principle Public read, owner-only updates/deletes.
     */
    match /temples/{templeId}/reviews/{reviewId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn();
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    function isSignedIn() {
      return request.auth != null;
    }
  }
}