/**
 * @file Firebase Security Rules for the aaura app.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data (profiles, preferences, bookmarks, playlists, etc.) while allowing public read access to content collections (media, temples, deities, etc.) with owner-only writes.
 *
 * Data Structure:
 * - User data is nested under /users/{userId}, ensuring only the user can manage their information.
 * - Public content (media, temples, deities, stories, rituals, festivals) resides in top-level collections, enabling broad access for discovery.
 * - Social connections (followers/following) are modeled as subcollections under the user's document.
 * - E-commerce data (shops, products, carts, orders) resides at the top-level. Cart and order data is duplicated in the user's document.
 *
 * Key Security Decisions:
 * - Users can only read and write their own data under their /users/{userId} path.
 * - Public content collections are readable by anyone, but only content owners (identified by a userId field) can create, update, or delete content.
 * - User listing is disallowed for privacy.
 * - Data model favors denormalization for authorization to avoid costly `get()` operations in rules.
 *
 * Denormalization for Authorization:
 * - Owner ID fields (e.g., `userId`, `authorId`, `creatorId`) are used extensively to determine write access to public content.
 * - Subcollections of user-owned collections inherit the ownership constraint from the parent path.
 *
 * Structural Segregation:
 * - Private user data (preferences, bookmarks) is stored under the /users/{userId} path, while public content (temples, deities) is stored in top-level collections. This separation simplifies security rules and improves query performance.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to read and write their own profile data.
     * @path /users/{userId}
     * @allow (create) - User with UID 'user_abc' can create their profile document.
     * @allow (get, update, delete) - User with UID 'user_abc' can read, update, or delete their own profile.
     * @deny (create, update, delete) - User with UID 'user_xyz' cannot create, update, or delete the profile of user 'user_abc'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.auth.uid == userId;
      allow update: if isOwner(userId) && resource.data.id == userId;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows a user to create, read, and delete their follower subcollection
     * @path /users/{userId}/followers/{followerId}
     * @allow (create, get, list, delete) - User with UID 'user_abc' can create a follow relationship where they are the follower.
     * @deny (create, get, list, delete) - User with UID 'user_xyz' cannot create, read, or delete follow relationships for user 'user_abc'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/followers/{followerId} {
        allow get, list: if isOwner(userId);
        allow create: if isSignedIn() && request.auth.uid == followerId;
        allow update, delete: if false;
    }

    /**
     * @description Allows a user to create, read, and delete their following subcollection
     * @path /users/{userId}/following/{followedId}
     * @allow (create, get, list, delete) - User with UID 'user_abc' can create a follow relationship where they are following another user.
     * @deny (create, get, list, delete) - User with UID 'user_xyz' cannot create, read, or delete follow relationships for user 'user_abc'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/following/{followedId} {
        allow get, list: if isOwner(userId);
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update, delete: if false;
    }

    /**
     * @description Allows users to read and write their own preferences.
     * @path /users/{userId}/preferences/default
     * @allow (get, create, update) - User with UID 'user_abc' can read, create, or update their preferences.
     * @deny (get, create, update) - User with UID 'user_xyz' cannot read, create, or update the preferences of user 'user_abc'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/preferences/default {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if false; // Preferences should not be deleted.
    }

    /**
     * @description Allows users to read their own badges and badges to be created only by the system(no one else).
     * @path /users/{userId}/badges/{badgeId}
     * @allow (get, list) - User with UID 'user_abc' can read their badges.
     * @deny (create, update, delete) - No one can create, update or delete badges.
     * @principle Enforces document ownership for read operations; restricts write operations.
     */
    match /users/{userId}/badges/{badgeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create, update, delete: if false; // Badges are awarded by the system, not users.
    }

    /**
     * @description Allows users to read and manage their own bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (get, create, update, delete) - User with UID 'user_abc' can manage their own bookmarks.
     * @deny (get, create, update, delete) - User with UID 'user_xyz' cannot manage the bookmarks of user 'user_abc'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/bookmarks/{bookmarkId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false; //bookmark ID should not be updated
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows users to read and write their virtual offering interactions.
     * @path /users/{userId}/virtualOfferings/{offeringId}
     * @allow (get, create, update, delete) - User with UID 'user_abc' can manage their own virtual offerings.
     * @deny (get, create, update, delete) - User with UID 'user_xyz' cannot manage the virtual offerings of user 'user_abc'.
     * @principle Enforces document ownership for all operations.
     */
    match /users/{userId}/virtualOfferings/{offeringId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if false; //Offering ID should not be updated
      allow delete: if isExistingOwner(userId);
    }

     /**
      * @description Allows users to read and write items in their shopping cart.
      * @path /users/{userId}/cart/{productId}
      * @allow (get, create, update, delete) - User with UID 'user_abc' can manage items in their cart.
      * @deny (get, create, update, delete) - User with UID 'user_xyz' cannot manage the cart of user 'user_abc'.
      * @principle Enforces document ownership for all operations.
      */
    match /users/{userId}/cart/{productId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows users to read their own order history. Orders can be created by anyone (e.g., system).
     * @path /users/{userId}/orders/{orderId}
     * @allow (get, list) - User with UID 'user_abc' can read their order history.
     * @deny (create, update, delete) - Users cannot create, update or delete orders directly.
     * @principle Enforces document ownership for read operations; restricts write operations.
     */
    match /users/{userId}/orders/{orderId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create, update, delete: if false;
    }

     /**
      * @description Allows users to read and write their own playlists.
      * @path /users/{userId}/playlists/{playlistId}
      * @allow (get, create, update, delete) - User with UID 'user_abc' can manage their own playlists.
      * @deny (get, create, update, delete) - User with UID 'user_xyz' cannot manage the playlists of user 'user_abc'.
      * @principle Enforces document ownership for all operations.
      */
    match /users/{userId}/playlists/{playlistId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to media, but restricts write access to the content owner.
     * @path /media/{mediaId}
     * @allow (get, list) - Anyone can read the media.
     * @allow (create) - User with UID 'user_abc' can create media with userId 'user_abc'.
     * @allow (update, delete) - User with UID 'user_abc' can update or delete their own media.
     * @deny (create) - User with UID 'user_xyz' cannot create media with userId 'user_abc'.
     * @deny (update, delete) - User with UID 'user_xyz' cannot update or delete media owned by 'user_abc'.
     * @principle Allows public read access with owner-only writes.
     */
    match /media/{mediaId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Allows users to read and write comments on media.
     * @path /media/{mediaId}/comments/{commentId}
     * @allow (get, list) - Anyone can read comments on a media item.
     * @allow (create) - User can create comments with their userId as authorId.
     * @allow (update, delete) - Only the comment's author can update or delete their comment.
     * @principle Allows public read access; enforces owner-only writes for updates and deletes.
     */
    match /media/{mediaId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows public read and allows users to like a media item and unlike it (delete).
     * @path /media/{mediaId}/likes/{userId}
     * @allow (get, list) - Anyone can see who liked a media item.
     * @allow (create, delete) - A signed-in user can like or unlike a media item (the document ID is their userId).
     * @principle Allows public read and authenticated writes.
     */
     match /media/{mediaId}/likes/{userId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if false; // Likes cannot be updated. Only created or deleted.
        allow delete: if isSignedIn() && request.auth.uid == userId;
     }

    /**
     * @description Allows public read access to channels, but restricts write access to the channel owner.
     * @path /channels/{channelId}
     * @allow (get, list) - Anyone can read a channel.
     * @allow (create) - User with UID 'user_abc' can create a channel with userId 'user_abc'.
     * @allow (update, delete) - User with UID 'user_abc' can update or delete their own channel.
     * @deny (create) - User with UID 'user_xyz' cannot create a channel with userId 'user_abc'.
     * @deny (update, delete) - User with UID 'user_xyz' cannot update or delete a channel owned by 'user_abc'.
     * @principle Allows public read access with owner-only writes.
     */
    match /channels/{channelId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Allows public read access to playlists, but restricts write access to the playlist creator.
     * @path /playlists/{playlistId}
     * @allow (get, list) - Anyone can read a playlist.
     * @allow (create) - User with UID 'user_abc' can create a playlist with creatorId 'user_abc'.
     * @allow (update, delete) - User with UID 'user_abc' can update or delete their own playlist.
     * @deny (create) - User with UID 'user_xyz' cannot create a playlist with creatorId 'user_abc'.
     * @deny (update, delete) - User with UID 'user_xyz' cannot update or delete a playlist owned by 'user_abc'.
     * @principle Allows public read access with owner-only writes.
     */
    match /playlists/{playlistId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.creatorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.creatorId);
      allow delete: if isExistingOwner(resource.data.creatorId);
    }

    /**
     * @description Allows users to read their own horoscopes.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (get, list) - User with UID 'user_abc' can read their own horoscopes.
     * @deny (create, update, delete) - No one can create, update or delete horoscopes.
     * @principle Enforces document ownership for read operations; restricts write operations.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create, update, delete: if false; // Horoscopes are generated by the system, not users.
    }

    /**
     * @description Allows public read access to deities.
     * @path /deities/{deityId}
     * @allow (get, list) - Anyone can read deity information.
     * @deny (create, update, delete) - No one can create, update, or delete deity information.
     * @principle Allows public read access; restricts write operations.
     */
    match /deities/{deityId} {
      allow get, list: if true;
      allow create, update, delete: if false; // Deity data is managed by the system, not users.
    }

    /**
     * @description Allows public read access to shops, but restricts write access to the shop owner.
     * @path /shops/{shopId}
     * @allow (get, list) - Anyone can read a shop.
     * @allow (create) - User with UID 'user_abc' can create a shop with ownerId 'user_abc'.
     * @allow (update, delete) - User with UID 'user_abc' can update or delete their own shop.
     * @deny (create) - User with UID 'user_xyz' cannot create a shop with ownerId 'user_abc'.
     * @deny (update, delete) - User with UID 'user_xyz' cannot update or delete a shop owned by 'user_abc'.
     * @principle Allows public read access with owner-only writes.
     */
    match /shops/{shopId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.ownerId);
      allow delete: if isExistingOwner(resource.data.ownerId);
    }

    /**
     * @description Allows public read access to products, but restricts write access.
     * @path /products/{productId}
     * @allow (get, list) - Anyone can read product information.
     * @deny (create, update, delete) - No one can create, update, or delete product information.
     * @principle Allows public read access; restricts write operations.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false; // Products are managed by admins through backend functions.
    }

    /**
     * @description Allows public read access to temples.
     * @path /temples/{templeId}
     * @allow (get, list) - Anyone can read temple information.
     * @deny (create, update, delete) - No one can create, update, or delete temple information.
     * @principle Allows public read access; restricts write operations.
     */
    match /temples/{templeId} {
      allow get, list: if true;
      allow create, update, delete: if false; // Temple data is managed by admins through backend functions.
    }

    /**
     * @description Allows users to read and write reviews for temples.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (get, list) - Anyone can read reviews for a temple.
     * @allow (create) - User can create reviews with their userId.
     * @allow (update, delete) - Only the review's author can update or delete their review.
     * @principle Allows public read access; enforces owner-only writes for updates and deletes.
     */
    match /temples/{templeId}/reviews/{reviewId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.userId);
      allow delete: if isExistingOwner(resource.data.userId);
    }

    /**
     * @description Allows public read access to mythological stories.
     * @path /stories/{storyId}
     * @allow (get, list) - Anyone can read story information.
     * @deny (create, update, delete) - No one can create, update, or delete story information.
     * @principle Allows public read access; restricts write operations.
     */
    match /stories/{storyId} {
      allow get, list: if true;
      allow create, update, delete: if false; // Story data is managed by admins through backend functions.
    }

    /**
     * @description Allows public read access to mythological characters.
     * @path /characters/{characterId}
     * @allow (get, list) - Anyone can read character information.
     * @deny (create, update, delete) - No one can create, update, or delete character information.
     * @principle Allows public read access; restricts write operations.
     */
    match /characters/{characterId} {
      allow get, list: if true;
      allow create, update, delete: if false; // Character data is managed by admins through backend functions.
    }

    /**
     * @description Allows public read access to rituals.
     * @path /rituals/{ritualId}
     * @allow (get, list) - Anyone can read ritual information.
     * @deny (create, update, delete) - No one can create, update, or delete ritual information.
     * @principle Allows public read access; restricts write operations.
     */
    match /rituals/{ritualId} {
      allow get, list: if true;
      allow create, update, delete: if false; // Ritual data is managed by admins through backend functions.
    }

    /**
     * @description Allows public read access to daily panchang data.
     * @path /panchang/{date}
     * @allow (get, list) - Anyone can read panchang information.
     * @deny (create, update, delete) - No one can create, update, or delete panchang information.
     * @principle Allows public read access; restricts write operations.
     */
    match /panchang/{date} {
      allow get, list: if true;
      allow create, update, delete: if false; // Panchang data is managed by a backend process.
    }

    /**
     * @description Allows public read access to festival data.
     * @path /festivals/{festivalId}
     * @allow (get, list) - Anyone can read festival information.
     * @deny (create, update, delete) - No one can create, update, or delete festival information.
     * @principle Allows public read access; restricts write operations.
     */
    match /festivals/{festivalId} {
      allow get, list: if true;
      allow create, update, delete: if false; // Festival data is managed by admins through backend functions.
    }

    /**
     * @description Allows public read access to posts, but restricts write access to the post author.
     * @path /posts/{postId}
     * @allow (get, list) - Anyone can read a post.
     * @allow (create) - User with UID 'user_abc' can create a post with authorId 'user_abc'.
     * @allow (update, delete) - User with UID 'user_abc' can update or delete their own post.
     * @deny (create) - User with UID 'user_xyz' cannot create a post with authorId 'user_abc'.
     * @deny (update, delete) - User with UID 'user_xyz' cannot update or delete a post owned by 'user_abc'.
     * @principle Allows public read access with owner-only writes.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows users to read and write comments on posts.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (get, list) - Anyone can read comments on a post.
     * @allow (create) - User can create comments with their userId as authorId.
     * @allow (update, delete) - Only the comment's author can update or delete their comment.
     * @principle Allows public read access; enforces owner-only writes for updates and deletes.
     */
    match /posts/{postId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows public read and allows users to like a post and unlike it (delete).
     * @path /posts/{postId}/likes/{userId}
     * @allow (get, list) - Anyone can see who liked a post.
     * @allow (create, delete) - A signed-in user can like or unlike a post (the document ID is their userId).
     * @principle Allows public read and authenticated writes.
     */
     match /posts/{postId}/likes/{userId} {
        allow get, list: if true;
        allow create: if isSignedIn() && request.auth.uid == userId;
        allow update: if false; // Likes cannot be updated. Only created or deleted.
        allow delete: if isSignedIn() && request.auth.uid == userId;
     }

    // --- Helper Functions ---

    /**
     * @description Checks if the user is signed in.
     * @return True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the document.
     * @param {string} userId - The user ID to check against.
     * @return True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of the document and the document exists.
     * @param {string} userId - The user ID to check against.
     * @return True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}