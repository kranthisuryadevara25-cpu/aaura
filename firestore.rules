/**
 * @fileoverview Firestore Security Rules for the aaura app.
 *
 * Core Philosophy:
 * This ruleset employs a hybrid security model, blending user-owned data trees with publicly readable collections, secured by owner-only writes. User-specific data is nested under `/users/{userId}` ensuring privacy. Public content, such as media and temples, reside in top-level collections allowing open reads but restricting writes to authenticated owners.
 *
 * Data Structure:
 * - User-specific data (profiles, bookmarks, cart, orders, preferences, playlists) is nested under `/users/{userId}`.
 * - Public content (media, channels, deities, shops, products, temples, stories, heroes, rituals, festivals, groups, posts, challenges, contests, manifestations) resides in top-level collections.
 * - Social graph implemented with `/users/{userId}/followers/{followerId}` and `/users/{userId}/following/{followedId}`.
 * - Likes are stored as subcollections under content items (e.g., `/media/{mediaId}/likes/{userId}`).
 *
 * Key Security Decisions:
 * - User listing is implicitly disallowed by the absence of a top-level `/users` collection.
 * - Public reads are allowed for top-level content collections.
 * - Writes to user documents and subcollections are restricted to the authenticated user (`isOwner`).
 * - The default security posture for ambiguous relationships is strict owner-only access.
 *
 * Denormalization for Authorization:
 * - While not explicitly present in the initial schema, consider denormalizing ownership information (e.g., `ownerId`) onto documents in top-level collections to simplify write rules and avoid costly `get()` calls. This applies especially to `Media`, `Channel`, and other top-level entities where owner-only writes are desired.
 *
 * Structural Segregation:
 * - Public and private data are strictly separated into top-level collections and user-specific subcollections, respectively.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is made by a signed-in user.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner and the document exists.
     * @param {string} userId The user ID to compare against.
     * @return {bool} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Enforces ownership for user documents.
     * @path /users/{userId}
     * @allow (create) - User 'alice' (auth.uid: 'alice') can create their own profile document (ID: 'alice').
     * @allow (get) - User 'alice' (auth.uid: 'alice') can read their own profile document (ID: 'alice').
     * @allow (update) - User 'alice' (auth.uid: 'alice') can update their own profile document (ID: 'alice').
     * @allow (delete) - User 'alice' (auth.uid: 'alice') can delete their own profile document (ID: 'alice').
     * @deny  (create) - User 'bob' (auth.uid: 'bob') cannot create a profile document for 'alice' (ID: 'alice').
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get, list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces ownership for user-specific contest progress.
     * @path /users/{userId}/contestProgress/{contestId}
     * @allow (create) - User 'alice' (auth.uid: 'alice') can create contest progress under their profile.
     * @allow (get) - User 'alice' (auth.uid: 'alice') can read their own contest progress.
     * @allow (update) - User 'alice' (auth.uid: 'alice') can update their own contest progress.
     * @allow (delete) - User 'alice' (auth.uid: 'alice') can delete their own contest progress.
     * @deny (create) - User 'bob' (auth.uid: 'bob') cannot create contest progress for 'alice'.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/contestProgress/{contestId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows a user to create, read, update, and delete their own followers.
     * @path /users/{userId}/followers/{followerId}
     * @allow (create) - User 'followerA' can create a 'follow' document under user 'followedB'.
     * @allow (get) - User 'followedB' can read who their followers are.
     * @allow (update) - User 'followerA' can update their 'follow' document under user 'followedB'.
     * @allow (delete) - User 'followerA' can delete their 'follow' document under user 'followedB'.
     * @deny (create) - User 'attacker' cannot create a 'follow' document under another user without authorization.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/followers/{followerId} {
      allow get, list: if isOwner(userId);
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Allows a user to create, read, update, and delete their own followings.
     * @path /users/{userId}/following/{followedId}
     * @allow (create) - User 'userA' can create a 'following' document under their profile for 'userB'.
     * @allow (get) - User 'userA' can read who they are following.
     * @allow (update) - User 'userA' can update their 'following' document under their profile for 'userB'.
     * @allow (delete) - User 'userA' can delete their 'following' document under their profile for 'userB'.
     * @deny (create) - User 'attacker' cannot create a 'following' document under another user without authorization.
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId}/following/{followedId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces ownership for user preferences (singleton document).
     * @path /users/{userId}/preferences/default
     * @allow (create) - User 'alice' (auth.uid: 'alice') can create preferences under their profile.
     * @allow (get) - User 'alice' (auth.uid: 'alice') can read their own preferences.
     * @allow (update) - User 'alice' (auth.uid: 'alice') can update their own preferences.
     * @allow (delete) - User 'alice' (auth.uid: 'alice') can delete their own preferences.
     * @deny (create) - User 'bob' (auth.uid: 'bob') cannot create preferences for 'alice'.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/preferences/default {
      allow get, list: if false;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces ownership for user badges.
     * @path /users/{userId}/badges/{badgeId}
     * @allow (create) - User 'alice' (auth.uid: 'alice') can create a badge document under their profile.
     * @allow (get) - User 'alice' (auth.uid: 'alice') can read their own badge.
     * @allow (update) - User 'alice' (auth.uid: 'alice') can update their own badge.
     * @allow (delete) - User 'alice' (auth.uid: 'alice') can delete their own badge.
     * @deny (create) - User 'bob' (auth.uid: 'bob') cannot create a badge for 'alice'.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/badges/{badgeId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces ownership for user bookmarks.
     * @path /users/{userId}/bookmarks/{bookmarkId}
     * @allow (create) - User 'alice' (auth.uid: 'alice') can create a bookmark under their profile.
     * @allow (get) - User 'alice' (auth.uid: 'alice') can read their own bookmarks.
     * @allow (update) - User 'alice' (auth.uid: 'alice') can update their own bookmark.
     * @allow (delete) - User 'alice' (auth.uid: 'alice') can delete their own bookmark.
     * @deny (create) - User 'bob' (auth.uid: 'bob') cannot create a bookmark for 'alice'.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/bookmarks/{bookmarkId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces ownership for user virtual offerings.
     * @path /users/{userId}/virtualOfferings/{offeringId}
     * @allow (create) - User 'alice' (auth.uid: 'alice') can create a virtual offering under their profile.
     * @allow (get) - User 'alice' (auth.uid: 'alice') can read their own virtual offerings.
     * @allow (update) - User 'alice' (auth.uid: 'alice') can update their own virtual offering.
     * @allow (delete) - User 'alice' (auth.uid: 'alice') can delete their own virtual offering.
     * @deny (create) - User 'bob' (auth.uid: 'bob') cannot create a virtual offering for 'alice'.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/virtualOfferings/{offeringId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces ownership for user cart items.
     * @path /users/{userId}/cart/{productId}
     * @allow (create) - User 'alice' (auth.uid: 'alice') can add an item to their cart.
     * @allow (get) - User 'alice' (auth.uid: 'alice') can view their cart.
     * @allow (update) - User 'alice' (auth.uid: 'alice') can update an item in their cart.
     * @allow (delete) - User 'alice' (auth.uid: 'alice') can remove an item from their cart.
     * @deny (create) - User 'bob' (auth.uid: 'bob') cannot add an item to 'alice's cart.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/cart/{productId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces ownership for user orders.
     * @path /users/{userId}/orders/{orderId}
     * @allow (create) - User 'alice' (auth.uid: 'alice') can create an order.
     * @allow (get) - User 'alice' (auth.uid: 'alice') can view their orders.
     * @allow (update) - User 'alice' (auth.uid: 'alice') can update their order.
     * @allow (delete) - User 'alice' (auth.uid: 'alice') can delete their order.
     * @deny (create) - User 'bob' (auth.uid: 'bob') cannot create an order for 'alice'.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/orders/{orderId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces ownership for user playlists.
     * @path /users/{userId}/playlists/{playlistId}
     * @allow (create) - User 'alice' (auth.uid: 'alice') can create a playlist under their profile.
     * @allow (get) - User 'alice' (auth.uid: 'alice') can read their own playlists.
     * @allow (update) - User 'alice' (auth.uid: 'alice') can update their own playlist.
     * @allow (delete) - User 'alice' (auth.uid: 'alice') can delete their own playlist.
     * @deny (create) - User 'bob' (auth.uid: 'bob') cannot create a playlist for 'alice'.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/playlists/{playlistId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Enforces ownership for user challenge progress.
     * @path /users/{userId}/challenges/{challengeId}
     * @allow (create) - User 'alice' (auth.uid: 'alice') can create challenge progress under their profile.
     * @allow (get) - User 'alice' (auth.uid: 'alice') can read their own challenge progress.
     * @allow (update) - User 'alice' (auth.uid: 'alice') can update their own challenge progress.
     * @allow (delete) - User 'alice' (auth.uid: 'alice') can delete their own challenge progress.
     * @deny (create) - User 'bob' (auth.uid: 'bob') cannot create challenge progress for 'alice'.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/challenges/{challengeId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to media, but restricts write access to owners.
     * @path /media/{mediaId}
     * @allow (get) - Any user can read media.
     * @allow (list) - Any user can list media.
     * // CRITICAL: Cannot implement owner-only writes. The 'Media' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /media/{mediaId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to media comments, but restricts write access.
     * @path /media/{mediaId}/comments/{commentId}
     * @allow (get) - Any user can read media comments.
     * @allow (list) - Any user can list media comments.
     * // CRITICAL: Cannot implement owner-only writes. The 'Comment' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /media/{mediaId}/comments/{commentId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation.
    }
    
    /**
     * @description Allows only signed in users to like a specific media item.
     * @path /media/{mediaId}/likes/{userId}
     * @allow (create) - Any signed in user can like any media.
     * @allow (get) - Any signed in user can read a media item's likes.
     * @allow (update) - Any signed in user can update their like on a media item.
     * @allow (delete) - Any signed in user can unlike a media item.
     * @principle  Allows only signed in users to like a media item.
     */
    match /media/{mediaId}/likes/{userId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if isSignedIn();
        allow delete: if isSignedIn();
    }

    /**
     * @description Allows public read access to channels, but restricts write access to owners.
     * @path /channels/{channelId}
     * @allow (get) - Any user can read a channel.
     * @allow (list) - Any user can list channels.
     * // CRITICAL: Cannot implement owner-only writes. The 'Channel' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /channels/{channelId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to playlists, but restricts write access to owners.
     * @path /playlists/{playlistId}
     * @allow (get) - Any user can read a playlist.
     * @allow (list) - Any user can list playlists.
     * // CRITICAL: Cannot implement owner-only writes. The 'Playlist' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /playlists/{playlistId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces ownership for user horoscopes.
     * @path /users/{userId}/horoscopes/{horoscopeId}
     * @allow (create) - User 'alice' (auth.uid: 'alice') can create a horoscope under their profile.
     * @allow (get) - User 'alice' (auth.uid: 'alice') can read their own horoscopes.
     * @allow (update) - User 'alice' (auth.uid: 'alice') can update their own horoscope.
     * @allow (delete) - User 'alice' (auth.uid: 'alice') can delete their own horoscope.
     * @deny (create) - User 'bob' (auth.uid: 'bob') cannot create a horoscope for 'alice'.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/horoscopes/{horoscopeId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to deities, but restricts write access to owners.
     * @path /deities/{deityId}
     * @allow (get) - Any user can read a deity.
     * @allow (list) - Any user can list deities.
     * // CRITICAL: Cannot implement owner-only writes. The 'Deity' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /deities/{deityId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to shops, but restricts write access to owners.
     * @path /shops/{shopId}
     * @allow (get) - Any user can read a shop.
     * @allow (list) - Any user can list shops.
     * // CRITICAL: Cannot implement owner-only writes. The 'Shop' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /shops/{shopId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to products, but restricts write access to owners.
     * @path /products/{productId}
     * @allow (get) - Any user can read a product.
     * @allow (list) - Any user can list products.
     * // CRITICAL: Cannot implement owner-only writes. The 'Product' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /products/{productId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to temples, but restricts write access to owners.
     * @path /temples/{templeId}
     * @allow (get) - Any user can read a temple.
     * @allow (list) - Any user can list temples.
     * // CRITICAL: Cannot implement owner-only writes. The 'Temple' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /temples/{templeId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to temple reviews, but restricts write access.
     * @path /temples/{templeId}/reviews/{reviewId}
     * @allow (get) - Any user can read temple reviews.
     * @allow (list) - Any user can list temple reviews.
     * // CRITICAL: Cannot implement owner-only writes. The 'Review' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /temples/{templeId}/reviews/{reviewId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation.
    }

   /**
     * @description Allows public read access to temples posts, but restricts write access.
     * @path /temples/{templeId}/posts/{postId}
     * @allow (get) - Any user can read temple posts.
     * @allow (list) - Any user can list temple posts.
     */
    match /temples/{templeId}/posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to stories, but restricts write access to owners.
     * @path /stories/{storyId}
     * @allow (get) - Any user can read a story.
     * @allow (list) - Any user can list stories.
     * // CRITICAL: Cannot implement owner-only writes. The 'Story' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /stories/{storyId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to epic heroes, but restricts write access to owners.
     * @path /epicHeroes/{heroId}
     * @allow (get) - Any user can read an epic hero.
     * @allow (list) - Any user can list epic heroes.
     * // CRITICAL: Cannot implement owner-only writes. The 'EpicHero' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /epicHeroes/{heroId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to rituals, but restricts write access to owners.
     * @path /rituals/{ritualId}
     * @allow (get) - Any user can read a ritual.
     * @allow (list) - Any user can list rituals.
     * // CRITICAL: Cannot implement owner-only writes. The 'Ritual' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /rituals/{ritualId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to panchang data.
     * @path /panchang/{date}
     * @allow (get) - Any user can read the panchang.
     * @allow (list) - Any user can list panchang data.
     * // CRITICAL: Cannot implement owner-only writes. The 'Panchang' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /panchang/{date} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to festivals, but restricts write access to owners.
     * @path /festivals/{festivalId}
     * @allow (get) - Any user can read a festival.
     * @allow (list) - Any user can list festivals.
     * // CRITICAL: Cannot implement owner-only writes. The 'Festival' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /festivals/{festivalId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to groups, but restricts write access to owners.
     * @path /groups/{groupId}
     * @allow (get) - Any user can read a group.
     * @allow (list) - Any user can list groups.
     * // CRITICAL: Cannot implement owner-only writes. The 'Group' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /groups/{groupId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows users to join and leave groups.
     * @path /groups/{groupId}/members/{userId}
     * @allow (create) - A user can create a membership document to join a group.
     * @allow (get) - Any user can get a membership document.
     * @allow (update) - A user can update their membership document (e.g., update the join timestamp).
     * @allow (delete) - A user can delete their membership document to leave a group.
     * @principle Users manage their own group memberships.
     */
    match /groups/{groupId}/members/{userId} {
      allow get, list: if true;
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to posts, but restricts write access to authenticated users.
     * @path /posts/{postId}
     * @allow (get) - Any user can read a post.
     * @allow (list) - Any user can list posts.
     * // CRITICAL: Cannot implement owner-only writes. The 'Post' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to comments, but restricts write access to authenticated users.
     * @path /posts/{postId}/comments/{commentId}
     * @allow (get) - Any user can read a comment.
     * @allow (list) - Any user can list comments.
     * // CRITICAL: Cannot implement owner-only writes. The 'Comment' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /posts/{postId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if false;
      allow delete: if false;
    }
    
    /**
     * @description Allows only signed in users to like a specific forum post.
     * @path /posts/{postId}/likes/{userId}
     * @allow (create) - Any signed in user can like any forum post.
     * @allow (get) - Any signed in user can read a forum post's likes.
     * @allow (update) - Any signed in user can update their like on a forum post.
     * @allow (delete) - Any signed in user can unlike a forum post.
     * @principle  Allows only signed in users to like a forum post.
     */
    match /posts/{postId}/likes/{userId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if isSignedIn();
        allow delete: if isSignedIn();
    }

    /**
     * @description Allows public read access to challenges, but restricts write access to owners.
     * @path /challenges/{challengeId}
     * @allow (get) - Any user can read a challenge.
     * @allow (list) - Any user can list challenges.
     * // CRITICAL: Cannot implement owner-only writes. The 'Challenge' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /challenges/{challengeId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

     /**
     * @description Allows public read access to contests, but restricts write access to owners.
     * @path /contests/{contestId}
     * @allow (get) - Any user can read a contest.
     * @allow (list) - Any user can list contests.
     */
    match /contests/{contestId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to manifestation posts, but restricts write access to owners.
     * @path /manifestations/{manifestationId}
     * @allow (get) - Any user can read a manifestation post.
     * @allow (list) - Any user can list manifestation posts.
     * // CRITICAL: Cannot implement owner-only writes. The 'Manifestation' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /manifestations/{manifestationId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // Any signed-in user can create manifestation posts
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to manifestation comments, but restricts write access to owners.
     * @path /manifestations/{manifestationId}/comments/{commentId}
     * @allow (get) - Any user can read a manifestation comment.
     * @allow (list) - Any user can list manifestation comments.
     * // CRITICAL: Cannot implement owner-only writes. The 'Comment' entity is missing an 'ownerId' or 'authorId' field.
     */
    match /manifestations/{manifestationId}/comments/{commentId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // Any signed-in user can create manifestation comments
      allow update: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
      allow delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
    
    /**
     * @description Allows only signed in users to like a specific manifestation post.
     * @path /manifestations/{manifestationId}/likes/{userId}
     * @allow (create) - Any signed in user can like any manifestation post.
     * @allow (get) - Any signed in user can read a manifestation post's likes.
     * @allow (update) - Any signed in user can update their like on a manifestation post.
     * @allow (delete) - Any signed in user can unlike a manifestation post.
     * @principle  Allows only signed in users to like a manifestation post.
     */
    match /manifestations/{manifestationId}/likes/{userId} {
        allow get, list: if true;
        allow create: if isSignedIn();
        allow update: if isSignedIn();
        allow delete: if isSignedIn();
    }
  }
}